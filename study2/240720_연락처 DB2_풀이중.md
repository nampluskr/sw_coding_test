### [풀이중] 버젼 1

```c++
#if 1
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <unordered_map>
#include <string>
#include <cstring>
using namespace std;

#define MAX_N			(5)
#define MAX_L			(8)

struct Result {
	int size;
	char mNameList[MAX_N][MAX_L + 1];
	char mTelephoneList[MAX_N][MAX_L + 1];
};

#define MAX_CONTACTS	(5000)		// add 3,000
#define MAX_LOGS		(13000)		// add 3,000 + call 10,000

enum State { EMPTY, ADDED, REMOVED };

struct DB {
	char mName[MAX_L + 1];
	char mTelephone[MAX_L + 1];
	State state;

	DB(const char mName[], const char mTelephone[], State state) {
		strcpy(this->mName, mName);
		strcpy(this->mTelephone, mTelephone);
		this->state = state;
	}
	DB() {
		strcpy(this->mName, "");
		strcpy(this->mTelephone, "");
		this->state = EMPTY;
	}

} db[MAX_CONTACTS];
int dbCnt;
unordered_map<string, int> nameMap;
unordered_map<string, int> telephoneMap;

struct LOG {
	char mName[MAX_L + 1];
	char mTelephone[MAX_L + 1];

	LOG(const char mName[], const char mTelephone[]) {
		strcpy(this->mName, mName);
		strcpy(this->mTelephone, mTelephone);
	}
	LOG() {
		strcpy(this->mName, "");
		strcpy(this->mTelephone, "");
	}
};
vector<LOG> nameLog[26];		// 'a' ~ 'z'
vector<LOG> telephoneLog[10];	// '0' ~ '9'


////////////////////////////////////////////////////////////////////
bool isName(const char mStr[]) {
	return isalpha(mStr[0]) && strlen(mStr);
}

bool isTelephone(const char mStr[]) {
	return isdigit(mStr[0]);
}

bool startsWith(char target[], char mStr[]) {
	for (int i = 0; i < strlen(mStr); i++)
		if (target[i] != mStr[i]) return false;
	return true;
}

bool findStr(const unordered_map<string, int>& map, const char mStr[]) {
	return map.find(mStr) != map.end();
}

bool isRemoved(char mStr[]) {
	if (isName(mStr) && findStr(nameMap, mStr))
		return db[nameMap[mStr]].state == REMOVED;
	else if (isTelephone(mStr) && findStr(telephoneMap, mStr))
		return db[telephoneMap[mStr]].state == REMOVED;
	return false;
}

////////////////////////////////////////////////////////////////////
void init()
{
	for (int i = 0; i < MAX_CONTACTS; i++) db[i] = {};
	nameMap.clear();
	telephoneMap.clear();
	dbCnt = 0;
	for (int i = 0; i < 26; i++) nameLog[i].clear();
	for (int i = 0; i < 10; i++) telephoneLog[i].clear();

}

void add(char mName[], char mTelephone[])
{
	// add db
	int idx = dbCnt++;	// db index
	db[idx] = { mName, mTelephone, ADDED };
	nameMap[mName] = idx;
	telephoneMap[mTelephone] = idx;

	// add log
	nameLog[mName[0] - 'a'].push_back({mName, mTelephone});
	telephoneLog[mTelephone[0] - '0'].push_back({ mName, mTelephone });
}

void remove(char mStr[])
{
	if (isName(mStr) && findStr(nameMap, mStr))
		db[nameMap[mStr]].state = REMOVED;
	else if (isTelephone(mStr) && findStr(telephoneMap, mStr))
		db[telephoneMap[mStr]].state = REMOVED;
}

void call(char mTelephone[])
{
	int idx;
	if (findStr(telephoneMap, mTelephone)) {
		idx = telephoneMap[mTelephone];
		char* mName = db[idx].mName;
		telephoneLog[mTelephone[0] - '0'].push_back({ mName, mTelephone });
		if (isName(mName))
			nameLog[mName[0] - 'a'].push_back({ mName, mTelephone });
	}
	else {
		idx = dbCnt++;
		db[idx] = { "", mTelephone, ADDED };
		telephoneMap[mTelephone] = idx;
		telephoneLog[mTelephone[0] - '0'].push_back({ "", mTelephone});
	}
}


Result search(char mStr[])
{
	Result ret = {};
	int cnt = 0;
	auto& logList = isName(mStr) ? nameLog[mStr[0] - 'a'] : telephoneLog[mStr[0] - '0'];

	for (int i = (int)logList.size() - 1; i >= 0 && cnt < 5; i--) {
		if (isTelephone(mStr) && isRemoved(logList[i].mTelephone)) continue;
		else if (isName(mStr) && isRemoved(logList[i].mName)) continue;

		if (isName(mStr) && !startsWith(logList[i].mName, mStr)) continue;
		else if (isTelephone(mStr) && !startsWith(logList[i].mTelephone, mStr)) continue;

		// 중복 제거
		int duplicated = false;
		for (int j = 0; j < cnt; j++) {
			if (isName(mStr) && strcmp(ret.mNameList[j], logList[i].mName) == 0) { 
				duplicated = true; break;
			}
			if (isTelephone(mStr) && strcmp(ret.mTelephoneList[j], logList[i].mTelephone) == 0) { 
				duplicated = true; break;
			}
		}
		if (duplicated) continue;

		strcpy(ret.mNameList[cnt], logList[i].mName);
		strcpy(ret.mTelephoneList[cnt], logList[i].mTelephone);
		ret.size++;
		cnt++;
	}
	return ret;
}
#endif
```

### [풀이중] 버젼 1

```c++
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <unordered_map>
#include <string>
#include <cstring>
using namespace std;

#define MAX_N			(5)
#define MAX_L			(8)

struct Result {
	int size;
	char mNameList[MAX_N][MAX_L + 1];
	char mTelephoneList[MAX_N][MAX_L + 1];
};


#define MAX_CONTACTS	(5000)		// add 3,000
#define MAX_LOGS		(13000)		// add 3,000 + call 10,000

enum State { ADDED, REMOVED };

struct DB {
	char mName[MAX_L + 1];
	char mTelephone[MAX_L + 1];
	State state;
} db[MAX_CONTACTS];
int dbCnt;
unordered_map<string, int> nameMap;
unordered_map<string, int> numberMap;

struct LOG {
	char mName[MAX_L + 1];
	char mTelephone[MAX_L + 1];
} logs[MAX_LOGS];
int logCnt;


////////////////////////////////////////////////////////////////////
bool isName(char mStr[]) {
	if ('a' <= mStr[0] && mStr[0] <= 'z') return true;
	return false;
}
bool isNumber(char mStr[]) {
	if ('0' <= mStr[0] && mStr[0] <= '9') return true;
	return false;
}

bool startsWith(char target[], char mStr[]) {
	for (int i = 0; i < strlen(mStr); i++)
		if (target[i] != mStr[i]) return false;
	return true;
}

bool isRemoved(char mStr[]) {
	State state = ADDED;
	if (isName(mStr) && nameMap.count(mStr)) state = db[nameMap[mStr]].state;
	else if (isNumber(mStr) && numberMap.count(mStr)) state = db[numberMap[mStr]].state;
	return (state == REMOVED) ? true : false;
}

////////////////////////////////////////////////////////////////////
void init()
{
	for (int i = 0; i < MAX_CONTACTS; i++) db[i] = {};
	for (int i = 0; i < MAX_LOGS; i++) logs[i] = {};
	nameMap.clear();
	numberMap.clear();
	dbCnt = 0;
	logCnt = 0;
}

void add(char mName[], char mTelephone[])
{
	// add db
	strcpy(db[dbCnt].mName, mName);
	strcpy(db[dbCnt].mTelephone, mTelephone);
	db[dbCnt].state = ADDED;

	nameMap[mName] = dbCnt;
	numberMap[mTelephone] = dbCnt;
	dbCnt++;

	// add log
	strcpy(logs[logCnt].mName, mName);
	strcpy(logs[logCnt].mTelephone, mTelephone);
	logCnt++;
}

void remove(char mStr[])
{
	if (isName(mStr) && nameMap.count(mStr))
		db[nameMap[mStr]].state = REMOVED;
	else if (isNumber(mStr) && numberMap.count(mStr)) 
		db[numberMap[mStr]].state = REMOVED;
}

void call(char mTelephone[])
{
	if (numberMap.find(mTelephone) != numberMap.end()) {
		int idx = numberMap[mTelephone];
		strcpy(logs[logCnt].mName, db[idx].mName);
	}
	else {
		strcpy(logs[logCnt].mName, "");

		strcpy(db[dbCnt].mName, "");
		strcpy(db[dbCnt].mTelephone, mTelephone);
		db[dbCnt].state = ADDED;

		numberMap[mTelephone] = dbCnt;

		dbCnt++;
	}
	strcpy(logs[logCnt].mTelephone, mTelephone);
	logCnt++;
}


Result search(char mStr[])
{
	Result ret = {};
	int cnt = 0;

	for (int i = logCnt - 1; i >= 0 && cnt < 5; i--) {
		if (isRemoved(logs[i].mTelephone)) continue;
		if (isName(mStr) && !startsWith(logs[i].mName, mStr)) continue;
		else if (isNumber(mStr) && !startsWith(logs[i].mTelephone, mStr)) continue;

		// 중복 제거
		int duplicated = false;
		for (int j = 0; j < cnt; j++) {
			if (isName(mStr) && strcmp(ret.mNameList[j], logs[i].mName) == 0) { duplicated = true; break; }
			else if (isNumber(mStr) && strcmp(ret.mTelephoneList[j], logs[i].mTelephone) == 0) { duplicated = true; break; }
		}
		if (duplicated) continue;

		strcpy(ret.mNameList[cnt], logs[i].mName);
		strcpy(ret.mTelephoneList[cnt], logs[i].mTelephone);
		ret.size++;
		cnt++;
	}

	return ret;
}
```
