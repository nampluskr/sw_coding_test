### [풀이중] 버젼 2

```c++
#if 1
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <unordered_map>
#include <string>
#include <cstring>
using namespace std;

#define MAX_N            (5)
#define MAX_L            (8)

struct Result {
    int size;
    char mNameList[MAX_N][MAX_L + 1];
    char mTelephoneList[MAX_N][MAX_L + 1];
};

#define MAX_CONTACTS    (5000)        // add 3,000
#define MAX_LOGS        (13000)        // add 3,000 + call 10,000

enum State { EMPTY, ADDED, REMOVED };

struct DB {
    char mName[MAX_L + 1];
    char mTelephone[MAX_L + 1];
    State state;

    DB(const char mName[], const char mTelephone[], State state) {
        strcpy(this->mName, mName);
        strcpy(this->mTelephone, mTelephone);
        this->state = state;
    }
    DB() {
        strcpy(this->mName, "");
        strcpy(this->mTelephone, "");
        this->state = EMPTY;
    }

} db[MAX_CONTACTS];
int dbCnt;
unordered_map<string, int> nameMap;
unordered_map<string, int> telephoneMap;

struct LOG {
    char mName[MAX_L + 1];
    char mTelephone[MAX_L + 1];

    LOG(const char mName[], const char mTelephone[]) {
        strcpy(this->mName, mName);
        strcpy(this->mTelephone, mTelephone);
    }
    LOG() {
        strcpy(this->mName, "");
        strcpy(this->mTelephone, "");
    }
};
vector<LOG> nameLog[26];        // 'a' ~ 'z'
vector<LOG> telephoneLog[10];    // '0' ~ '9'


////////////////////////////////////////////////////////////////////
bool isName(const char mStr[]) {
    return isalpha(mStr[0]) && strlen(mStr);
}

bool isTelephone(const char mStr[]) {
    return isdigit(mStr[0]);
}

bool startsWith(char target[], char mStr[]) {
    for (int i = 0; i < strlen(mStr); i++)
        if (target[i] != mStr[i]) return false;
    return true;
}

bool findStr(const unordered_map<string, int>& map, const char mStr[]) {
    return map.find(mStr) != map.end();
}

bool isRemoved(char mStr[]) {
    if (isName(mStr) && findStr(nameMap, mStr))
        return db[nameMap[mStr]].state == REMOVED;
    else if (isTelephone(mStr) && findStr(telephoneMap, mStr))
        return db[telephoneMap[mStr]].state == REMOVED;
    return false;
}

////////////////////////////////////////////////////////////////////
void init()
{
    for (int i = 0; i < MAX_CONTACTS; i++) db[i] = {};
    nameMap.clear();
    telephoneMap.clear();
    dbCnt = 0;
    for (int i = 0; i < 26; i++) nameLog[i].clear();
    for (int i = 0; i < 10; i++) telephoneLog[i].clear();

}

void add(char mName[], char mTelephone[])
{
    // add db
    int idx = dbCnt++;    // db index
    db[idx] = { mName, mTelephone, ADDED };
    nameMap[mName] = idx;
    telephoneMap[mTelephone] = idx;

    // add log
    nameLog[mName[0] - 'a'].push_back({mName, mTelephone});
    telephoneLog[mTelephone[0] - '0'].push_back({ mName, mTelephone });
}

void remove(char mStr[])
{
    if (isName(mStr) && findStr(nameMap, mStr))
        db[nameMap[mStr]].state = REMOVED;
    else if (isTelephone(mStr) && findStr(telephoneMap, mStr))
        db[telephoneMap[mStr]].state = REMOVED;
}

void call(char mTelephone[])
{
    int idx;
    if (findStr(telephoneMap, mTelephone)) {
        idx = telephoneMap[mTelephone];
        char* mName = db[idx].mName;
        telephoneLog[mTelephone[0] - '0'].push_back({ mName, mTelephone });
        if (isName(mName))
            nameLog[mName[0] - 'a'].push_back({ mName, mTelephone });
    }
    else {
        idx = dbCnt++;
        db[idx] = { "", mTelephone, ADDED };
        telephoneMap[mTelephone] = idx;
        telephoneLog[mTelephone[0] - '0'].push_back({ "", mTelephone});
    }
}


Result search(char mStr[])
{
    Result ret = {};
    int cnt = 0;
    auto& logList = isName(mStr) ? nameLog[mStr[0] - 'a'] : telephoneLog[mStr[0] - '0'];

    for (int i = (int)logList.size() - 1; i >= 0 && cnt < 5; i--) {
        if (isTelephone(mStr) && isRemoved(logList[i].mTelephone)) continue;
        else if (isName(mStr) && isRemoved(logList[i].mName)) continue;

        if (isName(mStr) && !startsWith(logList[i].mName, mStr)) continue;
        else if (isTelephone(mStr) && !startsWith(logList[i].mTelephone, mStr)) continue;

        // 중복 제거
        int duplicated = false;
        for (int j = 0; j < cnt; j++) {
            if (isName(mStr) && strcmp(ret.mNameList[j], logList[i].mName) == 0) { 
                duplicated = true; break;
            }
            if (isTelephone(mStr) && strcmp(ret.mTelephoneList[j], logList[i].mTelephone) == 0) { 
                duplicated = true; break;
            }
        }
        if (duplicated) continue;

        strcpy(ret.mNameList[cnt], logList[i].mName);
        strcpy(ret.mTelephoneList[cnt], logList[i].mTelephone);
        ret.size++;
        cnt++;
    }
    return ret;
}
#endif
```

### [풀이중] 버젼 1

```c++
#if 1
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <unordered_map>
#include <string>
#include <cstring>
using namespace std;

#define MAX_N            (5)
#define MAX_L            (8)

struct Result {
    int size;
    char mNameList[MAX_N][MAX_L + 1];
    char mTelephoneList[MAX_N][MAX_L + 1];
};

#define MAX_CONTACTS    (5000)        // add 3,000
#define MAX_LOGS        (13000)        // add 3,000 + call 10,000

enum State { EMPTY, ADDED, REMOVED };

struct DB {
    char mName[MAX_L + 1];
    char mTelephone[MAX_L + 1];
    State state;

    DB(const char mName[], const char mTelephone[], State state) {
        strcpy(this->mName, mName);
        strcpy(this->mTelephone, mTelephone);
        this->state = state;
    }
    DB() {
        strcpy(this->mName, "");
        strcpy(this->mTelephone, "");
        this->state = EMPTY;
    }

} db[MAX_CONTACTS];
int dbCnt;
unordered_map<string, int> nameMap;
unordered_map<string, int> telephoneMap;

struct LOG {
    char mName[MAX_L + 1];
    char mTelephone[MAX_L + 1];

    LOG(const char mName[], const char mTelephone[]) {
        strcpy(this->mName, mName);
        strcpy(this->mTelephone, mTelephone);
    }
    LOG() {
        strcpy(this->mName, "");
        strcpy(this->mTelephone, "");
    }
};
vector<LOG> nameLog[26];        // 'a' ~ 'z'
vector<LOG> telephoneLog[10];    // '0' ~ '9'


////////////////////////////////////////////////////////////////////
bool isName(const char mStr[]) {
    return isalpha(mStr[0]) && strlen(mStr);
}

bool isTelephone(const char mStr[]) {
    return isdigit(mStr[0]);
}

bool startsWith(char target[], char mStr[]) {
    for (int i = 0; i < strlen(mStr); i++)
        if (target[i] != mStr[i]) return false;
    return true;
}

bool findStr(const unordered_map<string, int>& map, const char mStr[]) {
    return map.find(mStr) != map.end();
}

bool isRemoved(char mStr[]) {
    if (isName(mStr) && findStr(nameMap, mStr))
        return db[nameMap[mStr]].state == REMOVED;
    else if (isTelephone(mStr) && findStr(telephoneMap, mStr))
        return db[telephoneMap[mStr]].state == REMOVED;
    return false;
}

////////////////////////////////////////////////////////////////////
void init()
{
    for (int i = 0; i < MAX_CONTACTS; i++) db[i] = {};
    nameMap.clear();
    telephoneMap.clear();
    dbCnt = 0;
    for (int i = 0; i < 26; i++) nameLog[i].clear();
    for (int i = 0; i < 10; i++) telephoneLog[i].clear();

}

void add(char mName[], char mTelephone[])
{
    // add db
    int idx = dbCnt++;    // db index
    db[idx] = { mName, mTelephone, ADDED };
    nameMap[mName] = idx;
    telephoneMap[mTelephone] = idx;

    // add log
    nameLog[mName[0] - 'a'].push_back({mName, mTelephone});
    telephoneLog[mTelephone[0] - '0'].push_back({ mName, mTelephone });
}

void remove(char mStr[])
{
    if (isName(mStr) && findStr(nameMap, mStr))
        db[nameMap[mStr]].state = REMOVED;
    else if (isTelephone(mStr) && findStr(telephoneMap, mStr))
        db[telephoneMap[mStr]].state = REMOVED;
}

void call(char mTelephone[])
{
    int idx;
    if (findStr(telephoneMap, mTelephone)) {
        idx = telephoneMap[mTelephone];
        char* mName = db[idx].mName;
        telephoneLog[mTelephone[0] - '0'].push_back({ mName, mTelephone });
        if (isName(mName))
            nameLog[mName[0] - 'a'].push_back({ mName, mTelephone });
    }
    else {
        idx = dbCnt++;
        db[idx] = { "", mTelephone, ADDED };
        telephoneMap[mTelephone] = idx;
        telephoneLog[mTelephone[0] - '0'].push_back({ "", mTelephone});
    }
}


Result search(char mStr[])
{
    Result ret = {};
    int cnt = 0;
    auto& logList = isName(mStr) ? nameLog[mStr[0] - 'a'] : telephoneLog[mStr[0] - '0'];

    for (int i = (int)logList.size() - 1; i >= 0 && cnt < 5; i--) {
        if (isTelephone(mStr) && isRemoved(logList[i].mTelephone)) continue;
        else if (isName(mStr) && isRemoved(logList[i].mName)) continue;

        if (isName(mStr) && !startsWith(logList[i].mName, mStr)) continue;
        else if (isTelephone(mStr) && !startsWith(logList[i].mTelephone, mStr)) continue;

        // 중복 제거
        int duplicated = false;
        for (int j = 0; j < cnt; j++) {
            if (isName(mStr) && strcmp(ret.mNameList[j], logList[i].mName) == 0) { 
                duplicated = true; break;
            }
            if (isTelephone(mStr) && strcmp(ret.mTelephoneList[j], logList[i].mTelephone) == 0) { 
                duplicated = true; break;
            }
        }
        if (duplicated) continue;

        strcpy(ret.mNameList[cnt], logList[i].mName);
        strcpy(ret.mTelephoneList[cnt], logList[i].mTelephone);
        ret.size++;
        cnt++;
    }
    return ret;
}
#endif
```
