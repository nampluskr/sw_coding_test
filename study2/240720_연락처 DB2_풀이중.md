#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <vector>
#include <unordered_map>
#include <string>
#include <cstring>
using namespace std;

#define MAX_N			(5)
#define MAX_L			(8)

struct Result {
	int size;
	char mNameList[MAX_N][MAX_L + 1];
	char mTelephoneList[MAX_N][MAX_L + 1];
};


#define MAX_CONTACTS	(5000)		// add 3,000
#define MAX_LOGS		(13000)		// add 3,000 + call 10,000

enum State { ADDED, REMOVED };

struct DB {
	char mName[MAX_L + 1];
	char mTelephone[MAX_L + 1];
	State state;
} db[MAX_CONTACTS];
int dbCnt;
unordered_map<string, int> nameMap;
unordered_map<string, int> numberMap;

struct LOG {
	char mName[MAX_L + 1];
	char mTelephone[MAX_L + 1];
} logs[MAX_LOGS];
int logCnt;


////////////////////////////////////////////////////////////////////
bool isName(char mStr[]) {
	if ('a' <= mStr[0] && mStr[0] <= 'z') return true;
	return false;
}
bool isNumber(char mStr[]) {
	if ('0' <= mStr[0] && mStr[0] <= '9') return true;
	return false;
}

bool startsWith(char target[], char mStr[]) {
	for (int i = 0; i < strlen(mStr); i++)
		if (target[i] != mStr[i]) return false;
	return true;
}

bool isRemoved(char mStr[]) {
	State state = ADDED;
	if (isName(mStr) && nameMap.count(mStr)) state = db[nameMap[mStr]].state;
	else if (isNumber(mStr) && numberMap.count(mStr)) state = db[numberMap[mStr]].state;
	return (state == REMOVED) ? true : false;
}

////////////////////////////////////////////////////////////////////
void init()
{
	for (int i = 0; i < MAX_CONTACTS; i++) db[i] = {};
	for (int i = 0; i < MAX_LOGS; i++) logs[i] = {};
	nameMap.clear();
	numberMap.clear();
	dbCnt = 0;
	logCnt = 0;
}

void add(char mName[], char mTelephone[])
{
	// add db
	strcpy(db[dbCnt].mName, mName);
	strcpy(db[dbCnt].mTelephone, mTelephone);
	db[dbCnt].state = ADDED;

	nameMap[mName] = dbCnt;
	numberMap[mTelephone] = dbCnt;
	dbCnt++;

	// add log
	strcpy(logs[logCnt].mName, mName);
	strcpy(logs[logCnt].mTelephone, mTelephone);
	logCnt++;
}

void remove(char mStr[])
{
	if (isName(mStr) && nameMap.count(mStr))
		db[nameMap[mStr]].state = REMOVED;
	else if (isNumber(mStr) && numberMap.count(mStr)) 
		db[numberMap[mStr]].state = REMOVED;
}

void call(char mTelephone[])
{
	if (numberMap.find(mTelephone) != numberMap.end()) {
		int idx = numberMap[mTelephone];
		strcpy(logs[logCnt].mName, db[idx].mName);
	}
	else {
		strcpy(logs[logCnt].mName, "");

		strcpy(db[dbCnt].mName, "");
		strcpy(db[dbCnt].mTelephone, mTelephone);
		db[dbCnt].state = ADDED;

		numberMap[mTelephone] = dbCnt;

		dbCnt++;
	}
	strcpy(logs[logCnt].mTelephone, mTelephone);
	logCnt++;
}


Result search(char mStr[])
{
	Result ret = {};
	int cnt = 0;

	for (int i = logCnt - 1; i >= 0 && cnt < 5; i--) {
		if (isRemoved(logs[i].mTelephone)) continue;
		if (isName(mStr) && !startsWith(logs[i].mName, mStr)) continue;
		else if (isNumber(mStr) && !startsWith(logs[i].mTelephone, mStr)) continue;

		// 중복 제거
		int duplicated = false;
		for (int j = 0; j < cnt; j++) {
			if (isName(mStr) && strcmp(ret.mNameList[j], logs[i].mName) == 0) { duplicated = true; break; }
			else if (isNumber(mStr) && strcmp(ret.mTelephoneList[j], logs[i].mTelephone) == 0) { duplicated = true; break; }
		}
		if (duplicated) continue;

		strcpy(ret.mNameList[cnt], logs[i].mName);
		strcpy(ret.mTelephoneList[cnt], logs[i].mTelephone);
		ret.size++;
		cnt++;
	}

	return ret;
}
