### KMJ

```cpp
#include <string.h>
 #define MAX_N 40000
 #define MAX_WORD 10000
 #define MAX_DICTIONARY_WORD 1000
 #define MAX_TABLE 15007

int hrp;
int dbwp;
int wordCount;
int getWordIDbyStartIdx[MAX_N];
int getWordIDbyEndIdx[MAX_N];
int offset[MAX_WORD];
int wIDs[MAX_WORD];
 
struct ListNode {
    int id;
    ListNode* next;
};
 
ListNode heap[1000000];
ListNode* dictionary[MAX_TABLE];
ListNode* correction[MAX_TABLE];
 
ListNode* appendListNode(int id, ListNode* next) {
    ListNode* node = &heap[hrp++];
    node->id = id;
    node->next = next;
    return node;
}
 
struct Word {
    char str[11];
    int len;
    bool isDictionaryWord;
    int hashkey[10];
};
 
Word db[MAX_WORD + MAX_DICTIONARY_WORD];
 
unsigned long hash(const char *str) {
    unsigned  long hash = 5381;
    int c;
 
    while (c = *str++) {
        hash = (((hash << 5) + hash) + c) % MAX_TABLE;
    }
    return hash % MAX_TABLE;
}
 
int getWordIdx(char mWord[]) {
    int hashkey = hash(mWord);
    ListNode* temp = dictionary[hashkey];
 
    while (temp != 0) {
        if (strcmp(db[temp->id].str, mWord) == 0)
            return temp->id;
 
        temp = temp->next;
    }
 
    dictionary[hashkey] = appendListNode(dbwp, dictionary[hashkey]);
    db[dbwp].len = strlen(mWord);
    strcpy(db[dbwp].str, mWord);
 
    for (int i = 0; i < db[dbwp].len; i++) {
        char org = db[dbwp].str[i];
        db[dbwp].str[i] = '_';
        int hashkey = db[dbwp].hashkey[i] = hash(db[dbwp].str);
        db[dbwp].str[i] = org;
    }
 
    return dbwp++;
}
 
void init(int N, char mString[])
{
    hrp = 0;
    dbwp = 0;
    wordCount = 0;
    char str[11];
    int wp = 0;
 
    for (int i = 0; i < MAX_TABLE; i++) {
        dictionary[i] = 0;
        correction[i] = 0;
    }
     
    for (int i = 0; i <= N; i++) {
        if (mString[i] == '_' || i == N) {
            getWordIDbyEndIdx[i - 1] = wordCount;
            str[wp] = 0;
            wp = 0;
 
            int wIdx = getWordIdx(str);
            db[wIdx].isDictionaryWord = false;
            wIDs[wordCount++] = wIdx;
        }
        else {
            if (wp == 0) {
                getWordIDbyStartIdx[i] = wordCount;
                offset[wordCount] = i;
            }
            str[wp++] = mString[i];
        }
    }
}
 
void addWord(char mWord[])
{
    int wIdx = getWordIdx(mWord);
    db[wIdx].isDictionaryWord = true;
 
    for (int i = 0; i < db[wIdx].len; i++) {
        int hashkey = db[wIdx].hashkey[i];
        correction[hashkey] = appendListNode(wIdx, correction[hashkey]);
    }
}
 
void removeWord(char mWord[])
{
    int wIdx = getWordIdx(mWord);
    db[wIdx].isDictionaryWord = false;
}
// 길이가 같은 두 단어를 비교하여 틀린 문자의 수를 리턴한다.
int getDiffCount(int orgWord, int newWord) {
    int count = 0;
 
    for (int i = 0; i < db[orgWord].len; i++) {
        if (db[orgWord].str[i] != db[newWord].str[i])
            count++;
    }
    return count;
}
// db[wIdx].str 단어가 교정이 될 수 있다면 그 교정될 단어의 idx를 리턴한다.
 // 만약 교정 대상단어가 없다면 -1을 리턴한다.
int getCorrectionWordIdx(int wIdx) {
    int ans = -1;
 
    for (int i = 0; i < db[wIdx].len; i++) {
        int hashkey = db[wIdx].hashkey[i];
        ListNode *temp = correction[hashkey];
 
        while (temp != 0) {
 
            if (db[temp->id].isDictionaryWord && db[wIdx].len == db[temp->id].len){
                if (getDiffCount(wIdx, temp->id) == 1) {
                    if (ans == -1)
                        ans = temp->id;
                    else if (strcmp(db[temp->id].str, db[ans].str) < 0)
                        ans = temp->id;
                }
            }
 
            temp = temp->next;
        }
    }
    return ans;
}
 
int correct(int mStart, int mEnd)
{
    int count = 0;
 
    for (int i = getWordIDbyStartIdx[mStart]; i <= getWordIDbyEndIdx[mEnd]; i++) {
        int wIdx = wIDs[i];
 
        if (db[wIdx].isDictionaryWord)
            continue;
 
        int correctionWordIdx = getCorrectionWordIdx(wIdx);
         
        if (correctionWordIdx != -1) {
            count++;
            wIDs[i] = correctionWordIdx;
        }
    }
    return count;
}
 
void destroy(char mResult[])
{
    for (int i = 0; i < wordCount; i++) {
        strcpy(&mResult[offset[i]], db[wIDs[i]].str);
        if(offset[i] != 0)
            mResult[offset[i] - 1] = '_';
    }
}
```
