### ChatGPT

```cpp

```

### Claude

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <algorithm>
using namespace std;

#define MAX_ITEMS 50000
#define MAX_CATEGORIES 6
#define MAX_COMPANIES 6

struct RESULT { int cnt, IDs[5]; };

struct Item {
    int mID, mCategory, mCompany, mPrice;
    bool isClosed;
} items[MAX_ITEMS];
int itemCnt;
unordered_map<int, int> itemMap;

struct Data {
    int mID, mPrice;
    bool operator<(const Data& other) {
        return (mPrice > other.mPrice) || (mPrice == other.mPrice && mID > other.mID);
    }
};
vector<Data> itemList[MAX_CATEGORIES][MAX_COMPANIES];
priority_queue<Data> itemPQ[MAX_CATEGORIES][MAX_COMPANIES];
int activeCount[MAX_CATEGORIES][MAX_COMPANIES];

void init() {
    itemCnt = 0;
    itemMap.clear();
    
    // 모든 아이템 리스트, 우선순위 큐, 활성 카운터 초기화
    for (int i = 1; i < MAX_CATEGORIES; i++) {
        for (int j = 1; j < MAX_COMPANIES; j++) {
            itemList[i][j].clear();
            while (!itemPQ[i][j].empty()) {
                itemPQ[i][j].pop();
            }
            activeCount[i][j] = 0;
        }
    }
}

int sell(int mID, int mCategory, int mCompany, int mPrice) {
    // 아이템 배열에 추가
    items[itemCnt] = {mID, mCategory, mCompany, mPrice, false};
    itemMap[mID] = itemCnt;
    itemCnt++;
    
    // 해당 리스트와 우선순위 큐에 추가
    Data data = {mID, mPrice};
    itemList[mCategory][mCompany].push_back(data);
    itemPQ[mCategory][mCompany].push(data);
    
    // 활성 카운트 증가
    activeCount[mCategory][mCompany]++;
    
    return activeCount[mCategory][mCompany];
}

int closeSale(int mID) {
    // 아이템 존재 여부 확인
    if (itemMap.find(mID) == itemMap.end()) {
        return -1;
    }
    
    int idx = itemMap[mID];
    Item& item = items[idx];
    
    // 이미 판매 종료된 아이템인지 확인
    if (item.isClosed) {
        return -1;
    }
    
    // 아이템 판매 종료
    item.isClosed = true;
    
    // 활성 카운트 감소
    activeCount[item.mCategory][item.mCompany]--;
    
    // 가격 반환
    return item.mPrice;
}

int discount(int mCategory, int mCompany, int mAmount) {
    // 카테고리와 제조사에 맞는 모든 아이템에 할인 적용
    vector<Data>& list = itemList[mCategory][mCompany];
    
    // 우선순위 큐와 활성 카운트 초기화
    while (!itemPQ[mCategory][mCompany].empty()) {
        itemPQ[mCategory][mCompany].pop();
    }
    activeCount[mCategory][mCompany] = 0;
    
    // 할인 적용 및 우선순위 큐 재구성
    for (Data& data : list) {
        int idx = itemMap[data.mID];
        Item& item = items[idx];
        
        if (!item.isClosed) {
            item.mPrice -= mAmount;
            data.mPrice = item.mPrice;
            
            if (item.mPrice <= 0) {
                item.isClosed = true;
            } else {
                itemPQ[mCategory][mCompany].push(data);
                activeCount[mCategory][mCompany]++;
            }
        }
    }
    
    return activeCount[mCategory][mCompany];
}

RESULT show(int mHow, int mCode) {
    RESULT result = {0, {0, 0, 0, 0, 0}};
    
    // 활성 아이템을 저장할 벡터
    vector<Data> activeItems;
    
    if (mHow == 0) {
        // 모든 카테고리와 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (int j = 1; j < MAX_COMPANIES; j++) {
                for (const Data& data : itemList[i][j]) {
                    int idx = itemMap[data.mID];
                    if (!items[idx].isClosed) {
                        activeItems.push_back({data.mID, items[idx].mPrice});
                    }
                }
            }
        }
    } else if (mHow == 1) {
        // 특정 카테고리의 아이템
        for (int j = 1; j < MAX_COMPANIES; j++) {
            for (const Data& data : itemList[mCode][j]) {
                int idx = itemMap[data.mID];
                if (!items[idx].isClosed) {
                    activeItems.push_back({data.mID, items[idx].mPrice});
                }
            }
        }
    } else if (mHow == 2) {
        // 특정 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (const Data& data : itemList[i][mCode]) {
                int idx = itemMap[data.mID];
                if (!items[idx].isClosed) {
                    activeItems.push_back({data.mID, items[idx].mPrice});
                }
            }
        }
    }
    
    // 가격 오름차순, 동일 가격은 ID 오름차순으로 정렬
    sort(activeItems.begin(), activeItems.end(), [](const Data& a, const Data& b) {
        return (a.mPrice < b.mPrice) || (a.mPrice == b.mPrice && a.mID < b.mID);
    });
    
    // 상위 5개 아이템 추출
    for (int i = 0; i < min(5, (int)activeItems.size()); i++) {
        result.IDs[result.cnt++] = activeItems[i].mID;
    }
    
    return result;
}
```