### ChatGPT

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

static const int MAX_ITEMS      = 200000;
static const int MAX_CATEGORIES = 6;  // 1..5
static const int MAX_COMPANIES  = 6;  // 1..5

// 결과 구조체
struct RESULT {
    int cnt;
    int IDs[5];
};

// 실제 상품 정보
struct Item {
    int mID, mCategory, mCompany, mPrice;
    bool isClosed;
} items[MAX_ITEMS];

int itemCnt;                                 // items 배열에 쌓인 개수
unordered_map<int,int> itemMap;              // mID -> items 인덱스

// PQ에 저장할 최소 힙용 데이터
struct Data {
    int mID, mPrice;  // mPrice는 "원가" (discount offset 적용 전 가격)
    bool operator<(const Data &o) const {
        if (mPrice != o.mPrice) return mPrice > o.mPrice;
        return mID    > o.mID;
    }
};

// lazy discount offset
int offsetDC[MAX_CATEGORIES][MAX_COMPANIES];
// 활성화된(판매 중인) 상품 수
int activeCnt[MAX_CATEGORIES][MAX_COMPANIES];
// (category, company)별 우선순위 큐
priority_queue<Data> itemPQ[MAX_CATEGORIES][MAX_COMPANIES];

// ———— 초기화 ————
void init() {
    itemCnt = 0;
    itemMap.clear();
    for (int c = 1; c <= 5; ++c) {
        for (int p = 1; p <= 5; ++p) {
            while (!itemPQ[c][p].empty())
                itemPQ[c][p].pop();
            offsetDC[c][p] = 0;
            activeCnt[c][p] = 0;
        }
    }
}

// ———— 상품 판매 시작 ————
// ———— 상품 판매 시작 ————
int sell(int mID, int mCategory, int mCompany, int mPrice) {
    // mID → items 인덱스(후증가) 반환
    int idx = itemMap[mID] = itemCnt++;
    // items[idx]에 정보 저장
    items[idx] = { mID, mCategory, mCompany, mPrice, false };
    // 해당 큐에 push
    itemPQ[mCategory][mCompany].push({ mID, mPrice });
    // 활성 카운트 증가
    ++activeCnt[mCategory][mCompany];
    // 현재 개수 반환
    return activeCnt[mCategory][mCompany];
}

// ———— 상품 판매 종료 ————
int closeSale(int mID) {
    auto it = itemMap.find(mID);
    if (it == itemMap.end()) return -1;
    int idx = it->second;
    if (items[idx].isClosed) return -1;

    int c = items[idx].mCategory;
    int p = items[idx].mCompany;
    int realPrice = items[idx].mPrice - offsetDC[c][p];

    items[idx].isClosed = true;
    --activeCnt[c][p];
    return realPrice;
}

// ———— PQ 정리 (stale / 이미 종료된 항목 제거) ————
void cleanPQ(int c, int p) {
    auto &pq = itemPQ[c][p];
    while (!pq.empty()) {
        Data top = pq.top();
        int idx = itemMap[top.mID];
        if (items[idx].isClosed || items[idx].mPrice != top.mPrice)
            pq.pop();
        else
            break;
    }
}

// ———— 할인 적용 ————
int discount(int mCategory, int mCompany, int mAmount) {
    offsetDC[mCategory][mCompany] += mAmount;
    cleanPQ(mCategory, mCompany);

    auto &pq = itemPQ[mCategory][mCompany];
    while (!pq.empty()) {
        Data top = pq.top();
        int idx = itemMap[top.mID];
        int eff = top.mPrice - offsetDC[mCategory][mCompany];
        if (eff <= 0) {
            items[idx].isClosed = true;
            --activeCnt[mCategory][mCompany];
            pq.pop();
        } else {
            break;
        }
    }
    return activeCnt[mCategory][mCompany];
}

// k-way merge를 위한 노드와 비교자
struct Node {
    int c, p;
    Data d;
};
struct NodeCmp {
    bool operator()(const Node &a, const Node &b) const {
        int ea = a.d.mPrice - offsetDC[a.c][a.p];
        int eb = b.d.mPrice - offsetDC[b.c][b.p];
        if (ea != eb) return ea > eb;
        return a.d.mID > b.d.mID;
    }
};

// ———— 조회 ————
RESULT show(int mHow, int mCode) {
    RESULT res;
    res.cnt = 0;
    for (int i = 0; i < 5; ++i) res.IDs[i] = 0;

    // 대상 (category,company) 목록 구성
    vector< pair<int,int> > targets;
    if (mHow == 0) {
        for (int c = 1; c <= 5; ++c)
            for (int p = 1; p <= 5; ++p)
                targets.push_back(make_pair(c,p));
    }
    else if (mHow == 1) {
        int c = mCode;
        for (int p = 1; p <= 5; ++p)
            targets.push_back(make_pair(c,p));
    }
    else {
        int p = mCode;
        for (int c = 1; c <= 5; ++c)
            targets.push_back(make_pair(c,p));
    }

    // 각 PQ 최상위 유효 항목을 k-way merge용 우선순위 큐에 넣기
    priority_queue<Node, vector<Node>, NodeCmp> hp;
    for (size_t i = 0; i < targets.size(); ++i) {
        int c = targets[i].first;
        int p = targets[i].second;
        cleanPQ(c,p);
        if (!itemPQ[c][p].empty())
            hp.push({c, p, itemPQ[c][p].top()});
    }

    // 상위 5개 추출 (pop 후 복구)
    vector<Node> popped;
    while (res.cnt < 5 && !hp.empty()) {
        Node cur = hp.top(); hp.pop();
        int c = cur.c, p = cur.p;
        res.IDs[res.cnt++] = cur.d.mID;

        // 실제 PQ에서 pop 하고, 다음 항목을 hp에 삽입
        itemPQ[c][p].pop();
        popped.push_back(cur);
        cleanPQ(c,p);
        if (!itemPQ[c][p].empty())
            hp.push({c, p, itemPQ[c][p].top()});
    }
    // 복구
    for (size_t i = 0; i < popped.size(); ++i) {
        int c = popped[i].c;
        int p = popped[i].p;
        itemPQ[c][p].push(popped[i].d);
    }

    return res;
}
```

### Claude

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <set>
#include <algorithm>
using namespace std;

#define MAX_ITEMS 50000
#define MAX_CATEGORIES 6
#define MAX_COMPANIES 6

struct RESULT { int cnt, IDs[5]; };

struct Item {
    int mID, mCategory, mCompany, mPrice;
    bool isClosed;
} items[MAX_ITEMS];
int itemCnt;
unordered_map<int, int> itemMap;

// 우선순위 큐용 비교 구조체
struct DataComp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.second != b.second) return a.second > b.second; // 가격 오름차순
        return a.first > b.first; // ID 오름차순
    }
};

vector<int> itemList[MAX_CATEGORIES][MAX_COMPANIES]; // 배열 인덱스만 저장
// (category, company)별 우선순위 큐 - <ID, 가격> 쌍 저장
priority_queue<pair<int, int>, vector<pair<int, int>>, DataComp> itemPQ[MAX_CATEGORIES][MAX_COMPANIES];
// lazy discount offset
int offsetDC[MAX_CATEGORIES][MAX_COMPANIES];
// 활성화된(판매 중인) 상품 수
int activeCnt[MAX_CATEGORIES][MAX_COMPANIES];

void init() {
    itemCnt = 0;
    itemMap.clear();
    
    // 모든 아이템 리스트, 우선순위 큐, 활성 카운터 초기화
    for (int i = 1; i < MAX_CATEGORIES; i++) {
        for (int j = 1; j < MAX_COMPANIES; j++) {
            itemList[i][j].clear();
            while (!itemPQ[i][j].empty()) {
                itemPQ[i][j].pop();
            }
            offsetDC[i][j] = 0;
            activeCnt[i][j] = 0;
        }
    }
}

int sell(int mID, int mCategory, int mCompany, int mPrice) {
    // 아이템 배열에 추가 및 인덱스 할당
    int idx = itemMap[mID] = itemCnt++;
    items[idx] = {mID, mCategory, mCompany, mPrice, false};
    
    // 해당 리스트와 우선순위 큐에 추가
    itemList[mCategory][mCompany].push_back(idx);
    itemPQ[mCategory][mCompany].push({mID, mPrice});
    
    // 활성 카운트 증가
    activeCnt[mCategory][mCompany]++;
    
    return activeCnt[mCategory][mCompany];
}

int closeSale(int mID) {
    // 아이템 존재 여부 확인
    if (itemMap.find(mID) == itemMap.end()) {
        return -1;
    }
    
    int idx = itemMap[mID];
    Item& item = items[idx];
    
    // 이미 판매 종료된 아이템인지 확인
    if (item.isClosed) {
        return -1;
    }
    
    // 아이템 판매 종료
    item.isClosed = true;
    
    // 활성 카운트 감소
    activeCnt[item.mCategory][item.mCompany]--;
    
    // 가격 반환
    return item.mPrice;
}

int discount(int mCategory, int mCompany, int mAmount) {
    // lazy discount offset 업데이트
    offsetDC[mCategory][mCompany] += mAmount;
    
    // 우선순위 큐와 활성 카운트 초기화
    while (!itemPQ[mCategory][mCompany].empty()) {
        itemPQ[mCategory][mCompany].pop();
    }
    activeCnt[mCategory][mCompany] = 0;
    
    // 할인 적용 및 우선순위 큐 재구성
    for (int idx : itemList[mCategory][mCompany]) {
        Item& item = items[idx];
        
        if (!item.isClosed) {
            // 실제 가격에서 offset 적용
            int realPrice = item.mPrice - offsetDC[mCategory][mCompany];
            
            if (realPrice <= 0) {
                item.isClosed = true;
            } else {
                itemPQ[mCategory][mCompany].push({item.mID, realPrice});
                activeCnt[mCategory][mCompany]++;
            }
        }
    }
    
    return activeCnt[mCategory][mCompany];
}

RESULT show(int mHow, int mCode) {
    RESULT result = {0, {0, 0, 0, 0, 0}};
    
    // 최소 힙 우선순위 큐로 정렬 (가격 오름차순, 동일 가격은 ID 오름차순)
    priority_queue<pair<int, int>, vector<pair<int, int>>, DataComp> pq;
    
    if (mHow == 0) {
        // 모든 카테고리와 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (int j = 1; j < MAX_COMPANIES; j++) {
                for (int itemIdx : itemList[i][j]) {
                    Item& item = items[itemIdx];
                    if (!item.isClosed) {
                        // 실제 가격 계산 (lazy discount offset 적용)
                        int realPrice = item.mPrice - offsetDC[i][j];
                        if (realPrice > 0) {  // 0 이하면 이미 판매 종료됨
                            pq.push({item.mID, realPrice});
                            // 최대 5개만 유지
                            if (pq.size() > 5) pq.pop();
                        }
                    }
                }
            }
        }
    } else if (mHow == 1) {
        // 특정 카테고리의 아이템
        for (int j = 1; j < MAX_COMPANIES; j++) {
            for (int itemIdx : itemList[mCode][j]) {
                Item& item = items[itemIdx];
                if (!item.isClosed) {
                    // 실제 가격 계산 (lazy discount offset 적용)
                    int realPrice = item.mPrice - offsetDC[mCode][j];
                    if (realPrice > 0) {
                        pq.push({item.mID, realPrice});
                        if (pq.size() > 5) pq.pop();
                    }
                }
            }
        }
    } else if (mHow == 2) {
        // 특정 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (int itemIdx : itemList[i][mCode]) {
                Item& item = items[itemIdx];
                if (!item.isClosed) {
                    // 실제 가격 계산 (lazy discount offset 적용)
                    int realPrice = item.mPrice - offsetDC[i][mCode];
                    if (realPrice > 0) {
                        pq.push({item.mID, realPrice});
                        if (pq.size() > 5) pq.pop();
                    }
                }
            }
        }
    }
    
    // 임시 배열에 결과 저장 (스택처럼 역순으로 꺼내야 함)
    vector<int> temp;
    while (!pq.empty()) {
        temp.push_back(pq.top().first);
        pq.pop();
    }
    
    // 역순으로 결과 배열에 저장 (가격 낮은 순)
    for (int i = temp.size() - 1; i >= 0; i--) {
        result.IDs[result.cnt++] = temp[i];
    }
    
    return result;
}
```