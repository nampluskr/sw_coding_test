### ChatGPT

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <utility>
using namespace std;

static const int MAX_ITEMS      = 200000;
static const int MAX_CATEGORIES = 6;  // 1..5
static const int MAX_COMPANIES  = 6;  // 1..5

// 결과 구조체
struct RESULT {
    int cnt;
    int IDs[5];
};

// 실제 상품 정보: mPrice는 "storedPrice"
struct Item {
    int       mID, mCategory, mCompany;
    long long mPrice;   // original + offsetAtSell
    bool      isClosed;
} items[MAX_ITEMS];

int itemCnt;                                 // items에 금번 인덱스
unordered_map<int,int> itemMap;              // mID → items 인덱스

// PQ에 저장할 데이터: mPrice도 storedPrice
struct Data {
    int       mID;
    long long mPrice;
    bool operator<(const Data &o) const {
        if (mPrice != o.mPrice) return mPrice > o.mPrice;
        return mID    > o.mID;
    }
};

// lazy discount offset (64-bit)
long long offsetDC[MAX_CATEGORIES][MAX_COMPANIES];
// 활성화된 상품 개수
int activeCnt[MAX_CATEGORIES][MAX_COMPANIES];
// (category, company)별 PQ
priority_queue<Data> itemPQ[MAX_CATEGORIES][MAX_COMPANIES];

// — 초기화 —
void init() {
    itemCnt = 0;
    itemMap.clear();
    for (int c = 1; c <= 5; ++c) {
        for (int p = 1; p <= 5; ++p) {
            while (!itemPQ[c][p].empty())
                itemPQ[c][p].pop();
            offsetDC[c][p] = 0;
            activeCnt[c][p] = 0;
        }
    }
}

// — PQ 정리 (stale/종료 아이템 제거) —
void cleanPQ(int c, int p) {
    auto &pq = itemPQ[c][p];
    while (!pq.empty()) {
        Data top = pq.top();
        int idx = itemMap[top.mID];
        if (items[idx].isClosed || items[idx].mPrice != top.mPrice)
            pq.pop();
        else
            break;
    }
}

// — 상품 판매 시작 ——
int sell(int mID, int mCategory, int mCompany, int origPrice) {
    // mID → items 인덱스(후증가) 저장
    int idx = itemMap[mID] = itemCnt++;
    // storedPrice 계산 (과거 offset만큼 더해 둠)
    long long storedPrice = (long long)origPrice + offsetDC[mCategory][mCompany];
    items[idx] = { mID, mCategory, mCompany, storedPrice, false };

    itemPQ[mCategory][mCompany].push({ mID, storedPrice });
    ++activeCnt[mCategory][mCompany];
    return activeCnt[mCategory][mCompany];
}

// — 상품 판매 종료 ——
int closeSale(int mID) {
    auto it = itemMap.find(mID);
    if (it == itemMap.end()) return -1;
    int idx = it->second;
    if (items[idx].isClosed)   return -1;

    int c = items[idx].mCategory;
    int p = items[idx].mCompany;
    long long realPrice = items[idx].mPrice - offsetDC[c][p];

    items[idx].isClosed = true;
    --activeCnt[c][p];
    return (int)realPrice;
}

// — 할인 적용 ——
int discount(int mCategory, int mCompany, int mAmount) {
    offsetDC[mCategory][mCompany] += mAmount;
    cleanPQ(mCategory, mCompany);

    auto &pq = itemPQ[mCategory][mCompany];
    while (!pq.empty()) {
        Data top = pq.top();
        long long eff = top.mPrice - offsetDC[mCategory][mCompany];
        if (eff <= 0) {
            int idx = itemMap[top.mID];
            items[idx].isClosed = true;
            --activeCnt[mCategory][mCompany];
            pq.pop();
        } else {
            break;
        }
    }
    return activeCnt[mCategory][mCompany];
}

// k-way merge용 노드 + 비교자
struct Node {
    int       c, p;
    Data      d;
};
struct NodeCmp {
    bool operator()(const Node &a, const Node &b) const {
        long long ea = a.d.mPrice - offsetDC[a.c][a.p];
        long long eb = b.d.mPrice - offsetDC[b.c][b.p];
        if (ea != eb) return ea > eb;
        return a.d.mID > b.d.mID;
    }
};

// — 조회 ——
RESULT show(int mHow, int mCode) {
    RESULT res = {0,{0,0,0,0,0}};

    // 1) 대상 (c,p) 리스트 구성
    vector<pair<int,int>> targets;
    if (mHow == 0) {
        for (int c = 1; c <= 5; ++c)
            for (int p = 1; p <= 5; ++p)
                targets.emplace_back(c,p);
    }
    else if (mHow == 1) {
        for (int p = 1; p <= 5; ++p)
            targets.emplace_back(mCode,p);
    }
    else {
        for (int c = 1; c <= 5; ++c)
            targets.emplace_back(c,mCode);
    }

    // 2) 각 PQ 최상위 유효 항목만 모아 k-way merge
    priority_queue<Node, vector<Node>, NodeCmp> hp;
    for (auto &tp : targets) {
        int c = tp.first, p = tp.second;
        cleanPQ(c,p);
        if (!itemPQ[c][p].empty())
            hp.push({c,p,itemPQ[c][p].top()});
    }

    // 3) 상위 5개 뽑고, pop한 만큼 복구
    vector<Node> popped;
    while (res.cnt < 5 && !hp.empty()) {
        Node cur = hp.top(); hp.pop();
        int c = cur.c, p = cur.p;
        res.IDs[res.cnt++] = cur.d.mID;

        itemPQ[c][p].pop();
        popped.push_back(cur);
        cleanPQ(c,p);
        if (!itemPQ[c][p].empty())
            hp.push({c,p,itemPQ[c][p].top()});
    }
    for (auto &nd : popped)
        itemPQ[nd.c][nd.p].push(nd.d);

    return res;
}
```

### Claude

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <set>
#include <algorithm>
using namespace std;

#define MAX_ITEMS 50000
#define MAX_CATEGORIES 6
#define MAX_COMPANIES 6

struct RESULT { int cnt, IDs[5]; };

struct Item {
    int mID, mCategory, mCompany, mPrice;
    bool isClosed;
} items[MAX_ITEMS];
int itemCnt;
unordered_map<int, int> itemMap;

// 우선순위 큐용 비교 구조체
struct DataComp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.second != b.second) return a.second > b.second; // 가격 오름차순
        return a.first > b.first; // ID 오름차순
    }
};

vector<int> itemList[MAX_CATEGORIES][MAX_COMPANIES]; // 배열 인덱스만 저장
// (category, company)별 우선순위 큐 - <ID, 가격> 쌍 저장
priority_queue<pair<int, int>, vector<pair<int, int>>, DataComp> itemPQ[MAX_CATEGORIES][MAX_COMPANIES];
// lazy discount offset
int offsetDC[MAX_CATEGORIES][MAX_COMPANIES];
// 활성화된(판매 중인) 상품 수
int activeCnt[MAX_CATEGORIES][MAX_COMPANIES];

void init() {
    itemCnt = 0;
    itemMap.clear();
    
    // 모든 아이템 리스트, 우선순위 큐, 활성 카운터 초기화
    for (int i = 1; i < MAX_CATEGORIES; i++) {
        for (int j = 1; j < MAX_COMPANIES; j++) {
            itemList[i][j].clear();
            while (!itemPQ[i][j].empty()) {
                itemPQ[i][j].pop();
            }
            offsetDC[i][j] = 0;
            activeCnt[i][j] = 0;
        }
    }
}

int sell(int mID, int mCategory, int mCompany, int mPrice) {
    // 아이템 배열에 추가 및 인덱스 할당
    int idx = itemMap[mID] = itemCnt++;
    items[idx] = {mID, mCategory, mCompany, mPrice, false};
    
    // 해당 리스트와 우선순위 큐에 추가
    itemList[mCategory][mCompany].push_back(idx);
    itemPQ[mCategory][mCompany].push({mID, mPrice});
    
    // 활성 카운트 증가
    activeCnt[mCategory][mCompany]++;
    
    return activeCnt[mCategory][mCompany];
}

int closeSale(int mID) {
    // 아이템 존재 여부 확인
    if (itemMap.find(mID) == itemMap.end()) {
        return -1;
    }
    
    int idx = itemMap[mID];
    Item& item = items[idx];
    
    // 이미 판매 종료된 아이템인지 확인
    if (item.isClosed) {
        return -1;
    }
    
    // 아이템 판매 종료
    item.isClosed = true;
    
    // 활성 카운트 감소
    activeCnt[item.mCategory][item.mCompany]--;
    
    // 가격 반환
    return item.mPrice;
}

int discount(int mCategory, int mCompany, int mAmount) {
    // lazy discount offset 업데이트
    offsetDC[mCategory][mCompany] += mAmount;
    
    // 우선순위 큐와 활성 카운트 초기화
    while (!itemPQ[mCategory][mCompany].empty()) {
        itemPQ[mCategory][mCompany].pop();
    }
    activeCnt[mCategory][mCompany] = 0;
    
    // 할인 적용 및 우선순위 큐 재구성
    for (int idx : itemList[mCategory][mCompany]) {
        Item& item = items[idx];
        
        if (!item.isClosed) {
            // 실제 가격에서 offset 적용
            int realPrice = item.mPrice - offsetDC[mCategory][mCompany];
            
            if (realPrice <= 0) {
                item.isClosed = true;
            } else {
                itemPQ[mCategory][mCompany].push({item.mID, realPrice});
                activeCnt[mCategory][mCompany]++;
            }
        }
    }
    
    return activeCnt[mCategory][mCompany];
}

RESULT show(int mHow, int mCode) {
    RESULT result = {0, {0, 0, 0, 0, 0}};
    
    // 최소 힙 우선순위 큐로 정렬 (가격 오름차순, 동일 가격은 ID 오름차순)
    priority_queue<pair<int, int>, vector<pair<int, int>>, DataComp> pq;
    
    if (mHow == 0) {
        // 모든 카테고리와 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (int j = 1; j < MAX_COMPANIES; j++) {
                for (int itemIdx : itemList[i][j]) {
                    Item& item = items[itemIdx];
                    if (!item.isClosed) {
                        // 실제 가격 계산 (lazy discount offset 적용)
                        int realPrice = item.mPrice - offsetDC[i][j];
                        if (realPrice > 0) {  // 0 이하면 이미 판매 종료됨
                            pq.push({item.mID, realPrice});
                            // 최대 5개만 유지
                            if (pq.size() > 5) pq.pop();
                        }
                    }
                }
            }
        }
    } else if (mHow == 1) {
        // 특정 카테고리의 아이템
        for (int j = 1; j < MAX_COMPANIES; j++) {
            for (int itemIdx : itemList[mCode][j]) {
                Item& item = items[itemIdx];
                if (!item.isClosed) {
                    // 실제 가격 계산 (lazy discount offset 적용)
                    int realPrice = item.mPrice - offsetDC[mCode][j];
                    if (realPrice > 0) {
                        pq.push({item.mID, realPrice});
                        if (pq.size() > 5) pq.pop();
                    }
                }
            }
        }
    } else if (mHow == 2) {
        // 특정 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (int itemIdx : itemList[i][mCode]) {
                Item& item = items[itemIdx];
                if (!item.isClosed) {
                    // 실제 가격 계산 (lazy discount offset 적용)
                    int realPrice = item.mPrice - offsetDC[i][mCode];
                    if (realPrice > 0) {
                        pq.push({item.mID, realPrice});
                        if (pq.size() > 5) pq.pop();
                    }
                }
            }
        }
    }
    
    // 임시 배열에 결과 저장 (스택처럼 역순으로 꺼내야 함)
    vector<int> temp;
    while (!pq.empty()) {
        temp.push_back(pq.top().first);
        pq.pop();
    }
    
    // 역순으로 결과 배열에 저장 (가격 낮은 순)
    for (int i = temp.size() - 1; i >= 0; i--) {
        result.IDs[result.cnt++] = temp[i];
    }
    
    return result;
}
```