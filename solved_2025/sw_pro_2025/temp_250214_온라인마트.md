### ChatGPT

```cpp
#include <bits/stdc++.h>
using namespace std;

constexpr int MAX_ITEMS      = 200000;
constexpr int MAX_CATEGORIES = 6;  // 1..5
constexpr int MAX_COMPANIES  = 6;  // 1..5

// 결과 구조체
struct RESULT {
    int cnt;
    int IDs[5];
};

// 실제 상품 정보
struct Item {
    int mID, mCategory, mCompany, mPrice;
    bool isClosed;
} items[MAX_ITEMS];

int itemCnt;                                   // items 배열에 쌓인 개수
unordered_map<int,int> itemMap;                // mID -> items 인덱스

// PQ에 저장할 최소 힙용 데이터
struct Data {
    int mID, mPrice;  // mPrice는 "원가" (discount offset 적용 전 가격)
    bool operator<(const Data& o) const {
        // priority_queue 는 최대 힙이므로, 가격이 작을수록 그리고 mID가 작을수록 우선하도록 반전 비교
        if (mPrice != o.mPrice) return mPrice > o.mPrice;
        return mID    > o.mID;
    }
};

// (category, company)별 우선순위 큐
priority_queue<Data> itemPQ[MAX_CATEGORIES][MAX_COMPANIES];
// lazy discount offset
int offsetDC[MAX_CATEGORIES][MAX_COMPANIES];
// 활성화된(판매 중인) 상품 수
int activeCnt[MAX_CATEGORIES][MAX_COMPANIES];


// ———— 초기화 ————
void init() {
    itemCnt = 0;
    itemMap.clear();
    for (int c = 1; c <= 5; ++c) {
        for (int p = 1; p <= 5; ++p) {
            // PQ 비우기
            auto &pq = itemPQ[c][p];
            while (!pq.empty()) pq.pop();
            offsetDC[c][p] = 0;
            activeCnt[c][p] = 0;
        }
    }
}

// ———— 상품 판매 시작 ————
int sell(int mID, int mCategory, int mCompany, int mPrice) {
    // 1) items에 등록
    items[itemCnt] = {mID, mCategory, mCompany, mPrice, false};
    itemMap[mID] = itemCnt;
    // 2) 해당 PQ에 push
    itemPQ[mCategory][mCompany].push({mID, mPrice});
    // 3) 활성 카운트 증가
    activeCnt[mCategory][mCompany]++;
    itemCnt++;
    return activeCnt[mCategory][mCompany];
}

// ———— 상품 판매 종료 ————
int closeSale(int mID) {
    auto it = itemMap.find(mID);
    if (it == itemMap.end()) return -1;
    int idx = it->second;
    if (items[idx].isClosed) return -1;

    int c = items[idx].mCategory;
    int p = items[idx].mCompany;
    // 실제 판매가 = 원가 – offset
    int realPrice = items[idx].mPrice - offsetDC[c][p];

    items[idx].isClosed = true;
    activeCnt[c][p]--;
    return realPrice;
}

// ———— 할인 적용 ————
int discount(int mCategory, int mCompany, int mAmount) {
    int &off = offsetDC[mCategory][mCompany];
    off += mAmount;

    auto &pq = itemPQ[mCategory][mCompany];
    // 가격이 0이하가 된 상품은 PQ에서 제거하고 닫기
    while (!pq.empty()) {
        Data top = pq.top();
        int idx = itemMap[top.mID];
        // 이미 종료되었거나 stale 데이터면 그냥 pop
        if (items[idx].isClosed || items[idx].mPrice != top.mPrice) {
            pq.pop();
            continue;
        }
        // effective price 계산
        int eff = top.mPrice - off;
        if (eff <= 0) {
            items[idx].isClosed = true;
            activeCnt[mCategory][mCompany]--;
            pq.pop();
        } else {
            break;
        }
    }
    return activeCnt[mCategory][mCompany];
}

// 내부: PQ 맨 위에 있는 stale/종료 항목들을 제거
void cleanPQ(int c, int p) {
    auto &pq = itemPQ[c][p];
    while (!pq.empty()) {
        Data top = pq.top();
        int idx = itemMap[top.mID];
        if (items[idx].isClosed || items[idx].mPrice != top.mPrice) {
            pq.pop();
        } else {
            break;
        }
    }
}

// ———— 조회 ————
RESULT show(int mHow, int mCode) {
    RESULT res{0, {0,0,0,0,0}};

    // k-way merge를 위한 임시 구조체
    struct Node {
        int c, p;
        Data d;
    };
    auto cmpNode = [&](const Node &a, const Node &b){
        int ea = a.d.mPrice - offsetDC[a.c][a.p];
        int eb = b.d.mPrice - offsetDC[b.c][b.p];
        if (ea != eb) return ea > eb;
        return a.d.mID > b.d.mID;
    };
    priority_queue<Node, vector<Node>, decltype(cmpNode)> hp(cmpNode);

    // 1) 대상 (category,company) 쌍을 열거
    vector<pair<int,int>> targets;
    if (mHow == 0) {
        for (int c = 1; c <= 5; ++c)
            for (int p = 1; p <= 5; ++p)
                targets.emplace_back(c,p);
    }
    else if (mHow == 1) {
        int c = mCode;
        for (int p = 1; p <= 5; ++p) targets.emplace_back(c,p);
    }
    else {
        int p = mCode;
        for (int c = 1; c <= 5; ++c) targets.emplace_back(c,p);
    }

    // 2) 각 PQ의 현재 최상위 유효 항목을 hp에 삽입
    for (auto [c,p] : targets) {
        cleanPQ(c,p);
        auto &pq = itemPQ[c][p];
        if (!pq.empty()) {
            hp.push({c,p,pq.top()});
        }
    }

    // 3) k-way merge: 상위 5개 뽑기
    //    뽑은 항목은 임시 pop 후 복구
    vector<Node> popped;
    while (res.cnt < 5 && !hp.empty()) {
        Node cur = hp.top(); hp.pop();
        int c = cur.c, p = cur.p;
        res.IDs[res.cnt++] = cur.d.mID;

        auto &pq = itemPQ[c][p];
        // 실제로 pop해서 다음 항목을 가져오기
        pq.pop();
        popped.push_back(cur);

        // 다음 유효 항목이 있으면 hp에 추가
        cleanPQ(c,p);
        if (!pq.empty()) {
            hp.push({c,p,pq.top()});
        }
    }

    // 4) pop했던 항목들 PQ에 복구
    for (auto &nd : popped) {
        itemPQ[nd.c][nd.p].push(nd.d);
    }

    return res;
}
```

### Claude

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <algorithm>
using namespace std;

#define MAX_ITEMS 50000
#define MAX_CATEGORIES 6
#define MAX_COMPANIES 6

struct RESULT { int cnt, IDs[5]; };

struct Item {
    int mID, mCategory, mCompany, mPrice;
    bool isClosed;
} items[MAX_ITEMS];
int itemCnt;
unordered_map<int, int> itemMap;

struct Data {
    int mID, mPrice;
    bool operator<(const Data& other) {
        return (mPrice > other.mPrice) || (mPrice == other.mPrice && mID > other.mID);
    }
};
vector<int> itemList[MAX_CATEGORIES][MAX_COMPANIES]; // 배열 인덱스만 저장
// (category, company)별 우선순위 큐
priority_queue<Data> itemPQ[MAX_CATEGORIES][MAX_COMPANIES];
// lazy discount offset
int offsetDC[MAX_CATEGORIES][MAX_COMPANIES];
// 활성화된(판매 중인) 상품 수
int activeCnt[MAX_CATEGORIES][MAX_COMPANIES];

void init() {
    itemCnt = 0;
    itemMap.clear();
    
    // 모든 아이템 리스트, 우선순위 큐, 활성 카운터 초기화
    for (int i = 1; i < MAX_CATEGORIES; i++) {
        for (int j = 1; j < MAX_COMPANIES; j++) {
            itemList[i][j].clear();
            while (!itemPQ[i][j].empty()) {
                itemPQ[i][j].pop();
            }
            offsetDC[i][j] = 0;
            activeCnt[i][j] = 0;
        }
    }
}

int sell(int mID, int mCategory, int mCompany, int mPrice) {
    // 아이템 배열에 추가 및 인덱스 할당
    int idx = itemMap[mID] = itemCnt++;
    items[idx] = {mID, mCategory, mCompany, mPrice, false};
    
    // 해당 리스트와 우선순위 큐에 추가
    itemList[mCategory][mCompany].push_back(idx);
    itemPQ[mCategory][mCompany].push({mID, mPrice});
    
    // 활성 카운트 증가
    activeCnt[mCategory][mCompany]++;
    
    return activeCnt[mCategory][mCompany];
}

int closeSale(int mID) {
    // 아이템 존재 여부 확인
    if (itemMap.find(mID) == itemMap.end()) {
        return -1;
    }
    
    int idx = itemMap[mID];
    Item& item = items[idx];
    
    // 이미 판매 종료된 아이템인지 확인
    if (item.isClosed) {
        return -1;
    }
    
    // 아이템 판매 종료
    item.isClosed = true;
    
    // 활성 카운트 감소
    activeCnt[item.mCategory][item.mCompany]--;
    
    // 가격 반환
    return item.mPrice;
}

int discount(int mCategory, int mCompany, int mAmount) {
    // lazy discount offset 업데이트
    offsetDC[mCategory][mCompany] += mAmount;
    
    // 우선순위 큐와 활성 카운트 초기화
    while (!itemPQ[mCategory][mCompany].empty()) {
        itemPQ[mCategory][mCompany].pop();
    }
    activeCnt[mCategory][mCompany] = 0;
    
    // 할인 적용 및 우선순위 큐 재구성
    for (int idx : itemList[mCategory][mCompany]) {
        Item& item = items[idx];
        
        if (!item.isClosed) {
            // 실제 가격에서 offset 적용
            int realPrice = item.mPrice - offsetDC[mCategory][mCompany];
            
            if (realPrice <= 0) {
                item.isClosed = true;
            } else {
                itemPQ[mCategory][mCompany].push({item.mID, realPrice});
                activeCnt[mCategory][mCompany]++;
            }
        }
    }
    
    return activeCnt[mCategory][mCompany];
}
}

RESULT show(int mHow, int mCode) {
    RESULT result = {0, {0, 0, 0, 0, 0}};
    
    // 활성 아이템을 저장할 벡터
    vector<Data> activeItems;
    
    if (mHow == 0) {
        // 모든 카테고리와 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (int j = 1; j < MAX_COMPANIES; j++) {
                for (int itemIdx : itemList[i][j]) {
                    Item& item = items[itemIdx];
                    if (!item.isClosed) {
                        // 실제 가격 계산 (lazy discount offset 적용)
                        int realPrice = item.mPrice - offsetDC[i][j];
                        if (realPrice > 0) {  // 0 이하면 이미 판매 종료됨
                            activeItems.push_back({item.mID, realPrice});
                        }
                    }
                }
            }
        }
    } else if (mHow == 1) {
        // 특정 카테고리의 아이템
        for (int j = 1; j < MAX_COMPANIES; j++) {
            for (int itemIdx : itemList[mCode][j]) {
                Item& item = items[itemIdx];
                if (!item.isClosed) {
                    // 실제 가격 계산 (lazy discount offset 적용)
                    int realPrice = item.mPrice - offsetDC[mCode][j];
                    if (realPrice > 0) {
                        activeItems.push_back({item.mID, realPrice});
                    }
                }
            }
        }
    } else if (mHow == 2) {
        // 특정 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (int itemIdx : itemList[i][mCode]) {
                Item& item = items[itemIdx];
                if (!item.isClosed) {
                    // 실제 가격 계산 (lazy discount offset 적용)
                    int realPrice = item.mPrice - offsetDC[i][mCode];
                    if (realPrice > 0) {
                        activeItems.push_back({item.mID, realPrice});
                    }
                }
            }
        }
    }
    
    // 가격 오름차순, 동일 가격은 ID 오름차순으로 정렬
    sort(activeItems.begin(), activeItems.end(), [](const Data& a, const Data& b) -> bool {
        if (a.mPrice != b.mPrice) return a.mPrice < b.mPrice;
        return a.mID < b.mID;
    });
    
    // 상위 5개 아이템 추출
    for (int i = 0; i < min(5, (int)activeItems.size()); i++) {
        result.IDs[result.cnt++] = activeItems[i].mID;
    }
    
    return result;
}
```