### ChatGPT

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <utility>
using namespace std;

static const int MAX_ITEMS = 200000;
static const int MAX_CATEGORIES = 6;  // 1..5
static const int MAX_COMPANIES = 6;  // 1..5

struct RESULT {
    int cnt;
    int IDs[5];
};

struct Item {
    int       mID, mCategory, mCompany;
    int mPrice;   // original + offsetAtSell
    bool      isClosed;
} items[MAX_ITEMS];

int itemCnt;
unordered_map<int, int> itemMap;

struct Data {
    int       mID;
    int mPrice;   // storedPrice
    bool operator<(const Data& o) const {
        if (mPrice != o.mPrice) return mPrice > o.mPrice;
        return mID > o.mID;
    }
};

int offsetDC[MAX_CATEGORIES][MAX_COMPANIES];
int activeCnt[MAX_CATEGORIES][MAX_COMPANIES];
priority_queue<Data> itemPQ[MAX_CATEGORIES][MAX_COMPANIES];

void init() {
    itemCnt = 0;
    itemMap.clear();
    for (int c = 1; c <= 5; ++c) {
        for (int p = 1; p <= 5; ++p) {
            while (!itemPQ[c][p].empty()) itemPQ[c][p].pop();
            offsetDC[c][p] = 0;
            activeCnt[c][p] = 0;
        }
    }
}

void cleanPQ(int c, int p) {
    auto& pq = itemPQ[c][p];
    while (!pq.empty()) {
        Data top = pq.top();
        int idx = itemMap[top.mID];
        if (items[idx].isClosed || items[idx].mPrice != top.mPrice)
            pq.pop();
        else
            break;
    }
}

int sell(int mID, int mCategory, int mCompany, int origPrice) {
    int idx = itemMap[mID] = itemCnt++;
    int storedPrice = (int)origPrice + offsetDC[mCategory][mCompany];
    items[idx] = { mID, mCategory, mCompany, storedPrice, false };

    itemPQ[mCategory][mCompany].push({ mID, storedPrice });
    ++activeCnt[mCategory][mCompany];
    return activeCnt[mCategory][mCompany];
}

int closeSale(int mID) {
    auto it = itemMap.find(mID);
    if (it == itemMap.end()) return -1;
    int idx = it->second;
    if (items[idx].isClosed)   return -1;

    int c = items[idx].mCategory;
    int p = items[idx].mCompany;
    int realPrice = items[idx].mPrice - offsetDC[c][p];

    items[idx].isClosed = true;
    --activeCnt[c][p];
    return (int)realPrice;
}

int discount(int mCategory, int mCompany, int mAmount) {
    // 1) 판매중인 상품이 하나도 없으면, past-offset 누적 금지
    if (activeCnt[mCategory][mCompany] == 0)
        return 0;

    // 2) 실제 할인 처리
    offsetDC[mCategory][mCompany] += mAmount;
    auto& pq = itemPQ[mCategory][mCompany];

    // 3) 루프마다 stale+종료 항목 완전 제거, eff<=0 항목만 pop
    while (true) {
        cleanPQ(mCategory, mCompany);
        if (pq.empty()) break;

        Data top = pq.top();
        int eff = top.mPrice - offsetDC[mCategory][mCompany];
        if (eff <= 0) {
            int idx = itemMap[top.mID];
            items[idx].isClosed = true;
            --activeCnt[mCategory][mCompany];
            pq.pop();
        }
        else {
            break;
        }
    }
    return activeCnt[mCategory][mCompany];
}

struct Node {
    int c, p;
    Data d;
};
struct NodeCmp {
    bool operator()(const Node& a, const Node& b) const {
        int ea = a.d.mPrice - offsetDC[a.c][a.p];
        int eb = b.d.mPrice - offsetDC[b.c][b.p];
        if (ea != eb) return ea > eb;
        return a.d.mID > b.d.mID;
    }
};

RESULT show(int mHow, int mCode) {
    RESULT res = { 0, { 0, 0, 0, 0, 0 } };

    vector<pair<int, int>> targets;
    if (mHow == 0) {
        for (int c = 1; c <= 5; ++c)
            for (int p = 1; p <= 5; ++p)
                targets.push_back({ c, p });
    }
    else if (mHow == 1) {
        for (int p = 1; p <= 5; ++p)
            targets.push_back({ mCode, p });
    }
    else {
        for (int c = 1; c <= 5; ++c)
            targets.push_back({ c, mCode });
    }

    priority_queue<Node, vector<Node>, NodeCmp> hp;
    for (auto& tp : targets) {
        int c = tp.first, p = tp.second;
        cleanPQ(c, p);
        if (!itemPQ[c][p].empty())
            hp.push({ c, p, itemPQ[c][p].top() });
    }

    vector<Node> popped;
    while (res.cnt < 5 && !hp.empty()) {
        Node cur = hp.top(); hp.pop();
        int c = cur.c, p = cur.p;
        res.IDs[res.cnt++] = cur.d.mID;

        itemPQ[c][p].pop();
        popped.push_back(cur);

        cleanPQ(c, p);
        if (!itemPQ[c][p].empty())
            hp.push({ c, p, itemPQ[c][p].top() });
    }
    // 복구
    for (auto& nd : popped)
        itemPQ[nd.c][nd.p].push(nd.d);

    return res;
}
```

### Claude

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <set>
#include <algorithm>
using namespace std;

#define MAX_ITEMS 50000
#define MAX_CATEGORIES 6
#define MAX_COMPANIES 6

struct RESULT { int cnt, IDs[5]; };

struct Item {
    int mID, mCategory, mCompany, mPrice;
    bool isClosed;
} items[MAX_ITEMS];
int itemCnt;
unordered_map<int, int> itemMap;

// 우선순위 큐용 비교 구조체
struct DataComp {
    bool operator()(const pair<int, int>& a, const pair<int, int>& b) const {
        if (a.second != b.second) return a.second > b.second; // 가격 오름차순
        return a.first > b.first; // ID 오름차순
    }
};

vector<int> itemList[MAX_CATEGORIES][MAX_COMPANIES]; // 배열 인덱스만 저장
// (category, company)별 우선순위 큐 - <ID, 가격> 쌍 저장
priority_queue<pair<int, int>, vector<pair<int, int>>, DataComp> itemPQ[MAX_CATEGORIES][MAX_COMPANIES];
// lazy discount offset
int offsetDC[MAX_CATEGORIES][MAX_COMPANIES];
// 활성화된(판매 중인) 상품 수
int activeCnt[MAX_CATEGORIES][MAX_COMPANIES];

void init() {
    itemCnt = 0;
    itemMap.clear();
    
    // 모든 아이템 리스트, 우선순위 큐, 활성 카운터 초기화
    for (int i = 1; i < MAX_CATEGORIES; i++) {
        for (int j = 1; j < MAX_COMPANIES; j++) {
            itemList[i][j].clear();
            while (!itemPQ[i][j].empty()) {
                itemPQ[i][j].pop();
            }
            offsetDC[i][j] = 0;
            activeCnt[i][j] = 0;
        }
    }
}

int sell(int mID, int mCategory, int mCompany, int mPrice) {
    // 아이템 배열에 추가 및 인덱스 할당
    int idx = itemMap[mID] = itemCnt++;
    items[idx] = {mID, mCategory, mCompany, mPrice, false};
    
    // 해당 리스트와 우선순위 큐에 추가
    itemList[mCategory][mCompany].push_back(idx);
    itemPQ[mCategory][mCompany].push({mID, mPrice});
    
    // 활성 카운트 증가
    activeCnt[mCategory][mCompany]++;
    
    return activeCnt[mCategory][mCompany];
}

int closeSale(int mID) {
    // 아이템 존재 여부 확인
    if (itemMap.find(mID) == itemMap.end()) {
        return -1;
    }
    
    int idx = itemMap[mID];
    Item& item = items[idx];
    
    // 이미 판매 종료된 아이템인지 확인
    if (item.isClosed) {
        return -1;
    }
    
    // 아이템 판매 종료
    item.isClosed = true;
    
    // 활성 카운트 감소
    activeCnt[item.mCategory][item.mCompany]--;
    
    // 가격 반환
    return item.mPrice;
}

int discount(int mCategory, int mCompany, int mAmount) {
    // lazy discount offset 업데이트
    offsetDC[mCategory][mCompany] += mAmount;
    
    // 우선순위 큐와 활성 카운트 초기화
    while (!itemPQ[mCategory][mCompany].empty()) {
        itemPQ[mCategory][mCompany].pop();
    }
    activeCnt[mCategory][mCompany] = 0;
    
    // 할인 적용 및 우선순위 큐 재구성
    for (int idx : itemList[mCategory][mCompany]) {
        Item& item = items[idx];
        
        if (!item.isClosed) {
            // 실제 가격에서 offset 적용
            int realPrice = item.mPrice - offsetDC[mCategory][mCompany];
            
            if (realPrice <= 0) {
                item.isClosed = true;
            } else {
                itemPQ[mCategory][mCompany].push({item.mID, realPrice});
                activeCnt[mCategory][mCompany]++;
            }
        }
    }
    
    return activeCnt[mCategory][mCompany];
}

RESULT show(int mHow, int mCode) {
    RESULT result = {0, {0, 0, 0, 0, 0}};
    
    // 최소 힙 우선순위 큐로 정렬 (가격 오름차순, 동일 가격은 ID 오름차순)
    priority_queue<pair<int, int>, vector<pair<int, int>>, DataComp> pq;
    
    if (mHow == 0) {
        // 모든 카테고리와 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (int j = 1; j < MAX_COMPANIES; j++) {
                for (int itemIdx : itemList[i][j]) {
                    Item& item = items[itemIdx];
                    if (!item.isClosed) {
                        // 실제 가격 계산 (lazy discount offset 적용)
                        int realPrice = item.mPrice - offsetDC[i][j];
                        if (realPrice > 0) {  // 0 이하면 이미 판매 종료됨
                            pq.push({item.mID, realPrice});
                            // 최대 5개만 유지
                            if (pq.size() > 5) pq.pop();
                        }
                    }
                }
            }
        }
    } else if (mHow == 1) {
        // 특정 카테고리의 아이템
        for (int j = 1; j < MAX_COMPANIES; j++) {
            for (int itemIdx : itemList[mCode][j]) {
                Item& item = items[itemIdx];
                if (!item.isClosed) {
                    // 실제 가격 계산 (lazy discount offset 적용)
                    int realPrice = item.mPrice - offsetDC[mCode][j];
                    if (realPrice > 0) {
                        pq.push({item.mID, realPrice});
                        if (pq.size() > 5) pq.pop();
                    }
                }
            }
        }
    } else if (mHow == 2) {
        // 특정 제조사의 아이템
        for (int i = 1; i < MAX_CATEGORIES; i++) {
            for (int itemIdx : itemList[i][mCode]) {
                Item& item = items[itemIdx];
                if (!item.isClosed) {
                    // 실제 가격 계산 (lazy discount offset 적용)
                    int realPrice = item.mPrice - offsetDC[i][mCode];
                    if (realPrice > 0) {
                        pq.push({item.mID, realPrice});
                        if (pq.size() > 5) pq.pop();
                    }
                }
            }
        }
    }
    
    // 임시 배열에 결과 저장 (스택처럼 역순으로 꺼내야 함)
    vector<int> temp;
    while (!pq.empty()) {
        temp.push_back(pq.top().first);
        pq.pop();
    }
    
    // 역순으로 결과 배열에 저장 (가격 낮은 순)
    for (int i = temp.size() - 1; i >= 0; i--) {
        result.IDs[result.cnt++] = temp[i];
    }
    
    return result;
}
```
