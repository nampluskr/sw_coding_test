## 코드 템플릿

```cpp
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

#define MAX_N	300		// N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K	2000	// K: 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// DB
struct Road {
	int sCity, eCity, mToll;
	bool isRemoved;
};
Road roads[MAX_N];
int numRoads;
unordered_map<int, int> roadMap;	// ( 1 ≤ mId[i] ≤ 1,000,000,000 )

int N;		// 도시의 개수 ( 5 ≤ N ≤ 300 )
int K;		// 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// 그래프
struct Edge {
	int to, mToll;
};
vector<Edge> graph[MAX_N];		// 인접 리스트

// mId[i]: 도로 i의 ID ( 1 ≤ mId[i] ≤ 1,000,000,000 )
// mToll[i]: 도로 i의 통행료 ( 100 ≤ mToll[i] ≤ 1,000 )

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mToll) {
	int rIdx = roadMap[mId] = numRoads++;
	roads[rIdx] = { sCity, eCity, mToll, false };
	graph[sCity].push_back({ eCity, mToll });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[])
{
	::N = N, ::K = K;
	numRoads = 0;
	roadMap.clear();
	for (int i = 0; i < N; i++) graph[i].clear();

	for (int i = 0; i < K; i++) {
		add(mId[i], sCity[i], eCity[i], mToll[i]);
	}
}

void remove(int mId) {
	int rIdx = roadMap[mId];
	roads[rIdx].isRemoved = true;
}

int cost(int M, int sCity, int eCity) {
	return 0;
}
```

## claud3.7 - extended
```cpp
#include <vector>
#include <unordered_map>
#include <queue>
#include <climits>
using namespace std;

#define MAX_N	300		// N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K	2000	// K: 도로의 개수 ( 6 ≤ K ≤ 2,000 )
#define MAX_M   10      // M: 최대 할인권 개수

// DB
struct Road {
	int sCity, eCity, mToll;
	bool isRemoved;
};
Road roads[MAX_K];  // MAX_N이 아닌 MAX_K로 수정 (도로 최대 개수)
int numRoads;
unordered_map<int, int> roadMap;	// ( 1 ≤ mId[i] ≤ 1,000,000,000 )

int N;		// 도시의 개수 ( 5 ≤ N ≤ 300 )
int K;		// 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// 그래프
struct Edge {
	int to, mToll, roadIdx;  // roadIdx 추가하여 삭제 여부 확인 가능
};
vector<Edge> graph[MAX_N];		// 인접 리스트

// mId[i]: 도로 i의 ID ( 1 ≤ mId[i] ≤ 1,000,000,000 )
// mToll[i]: 도로 i의 통행료 ( 100 ≤ mToll[i] ≤ 1,000 )

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mToll) {
	int rIdx = roadMap[mId] = numRoads++;
	roads[rIdx] = { sCity, eCity, mToll, false };
	graph[sCity].push_back({ eCity, mToll, rIdx });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[])
{
	::N = N, ::K = K;
	numRoads = 0;
	roadMap.clear();
	for (int i = 0; i < N; i++) graph[i].clear();

	for (int i = 0; i < K; i++) {
		add(mId[i], sCity[i], eCity[i], mToll[i]);
	}
}

void remove(int mId) {
    // 존재하지 않는 mId에 대한 예외 처리 추가
    if (roadMap.find(mId) != roadMap.end()) {
        int rIdx = roadMap[mId];
        roads[rIdx].isRemoved = true;
    }
}

int cost(int M, int sCity, int eCity) {
    // 최소 비용 배열: minCost[city][usedCoupons]
    int minCost[MAX_N][MAX_M + 1];
    
    // 초기화
    for (int i = 0; i < N; i++) {
        for (int j = 0; j <= M; j++) {
            minCost[i][j] = INT_MAX;
        }
    }
    
    // 다익스트라 알고리즘용 우선순위 큐
    // {비용, {도시, 사용한 할인권 수}}
    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
    
    // 시작 상태 초기화
    pq.push({0, {sCity, 0}});
    minCost[sCity][0] = 0;
    
    while (!pq.empty()) {
        int currCost = pq.top().first;
        int currCity = pq.top().second.first;
        int usedCoupons = pq.top().second.second;
        pq.pop();
        
        // 현재 상태의 비용이 이미 알려진 최소 비용보다 크면 무시
        if (currCost > minCost[currCity][usedCoupons]) continue;
        
        // 목적지에 도달한 경우 (최적화: 조기 종료)
        if (currCity == eCity) {
            continue;  // 우선순위 큐 특성상 이미 최소 비용으로 도달한 상태
        }
        
        // 현재 도시에서 출발하는 모든 도로 탐색
        for (const Edge& edge : graph[currCity]) {
            // 삭제된 도로는 건너뛰기
            if (roads[edge.roadIdx].isRemoved) continue;
            
            int nextCity = edge.to;
            int toll = edge.mToll;
            
            // 할인권을 사용하지 않는 경우
            int newCost = currCost + toll;
            if (newCost < minCost[nextCity][usedCoupons]) {
                minCost[nextCity][usedCoupons] = newCost;
                pq.push({newCost, {nextCity, usedCoupons}});
            }
            
            // 할인권을 사용하는 경우 (남은 할인권이 있을 때)
            if (usedCoupons < M) {
                // 통행료의 50% 할인
                int discountedCost = currCost + toll / 2;
                if (discountedCost < minCost[nextCity][usedCoupons + 1]) {
                    minCost[nextCity][usedCoupons + 1] = discountedCost;
                    pq.push({discountedCost, {nextCity, usedCoupons + 1}});
                }
            }
        }
    }
    
    // 도착 도시에 도달할 수 있는 모든 상태 중 최소 비용 계산
    int minResult = INT_MAX;
    for (int i = 0; i <= M; i++) {
        if (minCost[eCity][i] < minResult) {
            minResult = minCost[eCity][i];
        }
    }
    
    return minResult == INT_MAX ? -1 : minResult;
}
```

```cpp

```
