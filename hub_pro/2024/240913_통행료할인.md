## 코드 템플릿

```cpp
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

#define MAX_N	300		// N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K	2000	// K: 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// DB
struct Road {
	int sCity, eCity, mToll;
	bool isRemoved;
};
Road roads[MAX_N];
int numRoads;
unordered_map<int, int> roadMap;	// ( 1 ≤ mId[i] ≤ 1,000,000,000 )

int N;		// 도시의 개수 ( 5 ≤ N ≤ 300 )
int K;		// 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// 그래프
struct Edge {
	int to, mToll;
};
vector<Edge> graph[MAX_N];		// 인접 리스트

// mId[i]: 도로 i의 ID ( 1 ≤ mId[i] ≤ 1,000,000,000 )
// mToll[i]: 도로 i의 통행료 ( 100 ≤ mToll[i] ≤ 1,000 )

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mToll) {
	int rIdx = roadMap[mId] = numRoads++;
	roads[rIdx] = { sCity, eCity, mToll, false };
	graph[sCity].push_back({ eCity, mToll });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[])
{
	::N = N, ::K = K;
	numRoads = 0;
	roadMap.clear();
	for (int i = 0; i < N; i++) graph[i].clear();

	for (int i = 0; i < K; i++) {
		add(mId[i], sCity[i], eCity[i], mToll[i]);
	}
}

void remove(int mId) {
	int rIdx = roadMap[mId];
	roads[rIdx].isRemoved = true;
}

int cost(int M, int sCity, int eCity) {
	return 0;
}
```

## claud3.7 - extended
```cpp
#include <vector>
#include <unordered_map>
#include <queue>
#include <climits>
using namespace std;

#define MAX_N	300		// N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K	2000	// K: 도로의 개수 ( 6 ≤ K ≤ 2,000 )
#define MAX_M   10      // M: 최대 할인권 개수
#define INF     0x7FFFFFFF  // INT_MAX 대신 사용하여 오버플로우 방지

// DB
struct Road {
	int sCity, eCity, mToll;
	bool isRemoved;
};
Road roads[MAX_K * 2];  // 추가 여유 공간 확보
int numRoads;
unordered_map<int, int> roadMap;	// ( 1 ≤ mId[i] ≤ 1,000,000,000 )

int N;		// 도시의 개수 ( 5 ≤ N ≤ 300 )
int K;		// 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// 통합된 Edge 구조체
struct Edge {
    // 그래프의 간선으로 사용되는 경우
    int to;             // 도착 도시
    int mToll;          // 통행료
    int roadIdx;        // 도로 인덱스
    
    // 다익스트라 알고리즘에서 사용되는 경우
    int cost;           // 현재까지의 비용
    int city;           // 현재 도시
    int usedCoupons;    // 사용한 할인권 수
    
    // 그래프 간선용 생성자
    Edge(int _to, int _mToll, int _roadIdx) 
        : to(_to), mToll(_mToll), roadIdx(_roadIdx), cost(0), city(0), usedCoupons(0) {}
    
    // 다익스트라용 생성자
    Edge(int _cost, int _city, int _usedCoupons) 
        : cost(_cost), city(_city), usedCoupons(_usedCoupons), to(0), mToll(0), roadIdx(0) {}
    
    // 우선순위 큐에서 비용이 적은 순서대로 나오도록 연산자 재정의
    bool operator<(const Edge& other) const {
        return cost > other.cost;  // 최소 힙을 위해 '>' 사용
    }
};

vector<Edge> graph[MAX_N];		// 인접 리스트

// mId[i]: 도로 i의 ID ( 1 ≤ mId[i] ≤ 1,000,000,000 )
// mToll[i]: 도로 i의 통행료 ( 100 ≤ mToll[i] ≤ 1,000 )

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mToll) {
	int rIdx = numRoads++;
	roadMap[mId] = rIdx;
	roads[rIdx] = { sCity, eCity, mToll, false };
	graph[sCity].push_back(Edge(eCity, mToll, rIdx));
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[])
{
	::N = N, ::K = K;
	numRoads = 0;
	roadMap.clear();
	for (int i = 0; i < N; i++) graph[i].clear();

	for (int i = 0; i < K; i++) {
		add(mId[i], sCity[i], eCity[i], mToll[i]);
	}
}

void remove(int mId) {
    // 존재하지 않는 mId에 대한 예외 처리 추가
    if (roadMap.find(mId) != roadMap.end()) {
        int rIdx = roadMap[mId];
        roads[rIdx].isRemoved = true;
    }
}

int cost(int M, int sCity, int eCity) {
    // 출발지와 도착지가 같은 경우
    if (sCity == eCity) return 0;
    
    // 할인권 개수가 0인 경우 예외 처리
    if (M <= 0) {
        // 일반 다익스트라로 최단 경로 찾기
        vector<int> dist(N, INF);
        priority_queue<Edge> pq;
        
        dist[sCity] = 0;
        pq.push(Edge(0, sCity, 0));
        
        while (!pq.empty()) {
            Edge curr = pq.top();
            pq.pop();
            
            if (curr.cost > dist[curr.city]) continue;
            
            for (const Edge& edge : graph[curr.city]) {
                if (roads[edge.roadIdx].isRemoved) continue;
                
                int nextCity = edge.to;
                int newCost = curr.cost + edge.mToll;
                
                if (newCost < dist[nextCity]) {
                    dist[nextCity] = newCost;
                    pq.push(Edge(newCost, nextCity, 0));
                }
            }
        }
        
        return dist[eCity] == INF ? -1 : dist[eCity];
    }
    
    // 최소 비용 배열: minCost[city][usedCoupons]
    int minCost[MAX_N][MAX_M + 1];
    
    // 초기화
    for (int i = 0; i < N; i++) {
        for (int j = 0; j <= M; j++) {
            minCost[i][j] = INF;
        }
    }
    
    // 다익스트라 알고리즘용 우선순위 큐
    priority_queue<Edge> pq;
    
    // 시작 상태 초기화
    pq.push(Edge(0, sCity, 0));
    minCost[sCity][0] = 0;
    
    while (!pq.empty()) {
        Edge curr = pq.top();
        pq.pop();
        
        // 현재 상태의 비용이 이미 알려진 최소 비용보다 크면 무시
        if (curr.cost > minCost[curr.city][curr.usedCoupons]) continue;
        
        // 현재 도시에서 출발하는 모든 도로 탐색
        for (const Edge& edge : graph[curr.city]) {
            // 삭제된 도로는 건너뛰기
            if (roads[edge.roadIdx].isRemoved) continue;
            
            int nextCity = edge.to;
            int toll = edge.mToll;
            
            // 할인권을 사용하지 않는 경우
            int newCost = curr.cost + toll;
            if (newCost < minCost[nextCity][curr.usedCoupons]) {
                minCost[nextCity][curr.usedCoupons] = newCost;
                pq.push(Edge(newCost, nextCity, curr.usedCoupons));
            }
            
            // 할인권을 사용하는 경우 (남은 할인권이 있을 때)
            if (curr.usedCoupons < M) {
                int discountedCost = curr.cost + (toll / 2);
                if (discountedCost < minCost[nextCity][curr.usedCoupons + 1]) {
                    minCost[nextCity][curr.usedCoupons + 1] = discountedCost;
                    pq.push(Edge(discountedCost, nextCity, curr.usedCoupons + 1));
                }
            }
        }
    }
    
    // 도착 도시에 도달할 수 있는 모든 상태 중 최소 비용 계산
    int minResult = INF;
    for (int i = 0; i <= M; i++) {
        if (minCost[eCity][i] < minResult) {
            minResult = minCost[eCity][i];
        }
    }
    
    return minResult == INF ? -1 : minResult;
}
```

## KDH
```cpp
#include<vector>
#include<unordered_map>
#include<queue>
#include<algorithm>
using namespace std;

#define MAX_CITY 303
#define MAX_ROAD 3403
#define MAX_DISCOUNT_TICKET 11
#define INF 987654321

struct DB {
	int s, e, c;
}db[MAX_ROAD];

struct Edge {
	int to, cost, used_coupon;
	bool operator<(const Edge& r)const {
		return cost > r.cost;
	}
	bool operator==(const Edge& r)const {
		return to == r.to && cost == r.cost;
	}
};

vector<Edge> adj[MAX_CITY];
unordered_map<int, int> idMap;
int idCnt, N, M;

int getID(int c) {
	return idMap.count(c) ? idMap[c] : idMap[c] = idCnt++;
}

void add(int mId, int sCity, int eCity, int mToll) {
	db[getID(mId)] = { sCity, eCity, mToll };
	adj[sCity].push_back({ eCity,mToll });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[]) {
	::N = N, idMap.clear(), idCnt = 0;
	for (int i = 0; i < MAX_CITY; i++) adj[i].clear();
	for (int i = 0; i < K; i++)	add(mId[i], sCity[i], eCity[i], mToll[i]);
}

void remove(int mId) {
	int id = getID(mId);
	int s = db[id].s, e = db[id].e, c = db[id].c;
	adj[s].erase(find(adj[s].begin(), adj[s].end(), Edge{ e, c }));
}

int costFinal[MAX_CITY][MAX_DISCOUNT_TICKET]; // 사용한 할인권 개수에 따른 최소 비용
int cost(int m, int s, int e) {
	for (int i = 0; i < N; i++) for (int j = 0; j < MAX_DISCOUNT_TICKET; j++) costFinal[i][j] = INF;
	costFinal[s][0] = 0;
	priority_queue<Edge> pq;
	pq.push({ s, 0, 0 }); // to, cost, used_coupon

	while (!pq.empty()) {
		Edge cur = pq.top(); pq.pop();
		if (cur.to == e && cur.used_coupon == m) {
			int ret = INF;
			for (int i = 1; i <= m; i++) ret = min(ret, costFinal[e][i]); // 할인권을 사용한다는 가정이 있음
			return ret == INF ? -1 : ret;
		}

		if (cur.cost > costFinal[cur.to][cur.used_coupon]) continue;

		for (Edge nx : adj[cur.to]) {
			int nextCost = cur.cost + nx.cost;
			if (costFinal[nx.to][cur.used_coupon] > nextCost) { // 할인권을 사용하지 않는 경우
				costFinal[nx.to][cur.used_coupon] = nextCost;
				pq.push({ nx.to, nextCost, cur.used_coupon });
			}
			if (cur.used_coupon <= m) { // 할인권을 사용할 수 있는 경우
				int discountCost = cur.cost + nx.cost / 2;
				//int discountCost = cost + (int)ceil(nx.cost / 2.0);
				if (costFinal[nx.to][cur.used_coupon + 1] > discountCost) {
					costFinal[nx.to][cur.used_coupon + 1] = discountCost;
					pq.push({ nx.to, discountCost, cur.used_coupon + 1 });
				}
			}
		}
	}
	return -1; // 도착하지 못하는 경우
}
```
