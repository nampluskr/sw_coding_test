## 코드 템플릿

```cpp
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

#define MAX_N	300		// N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K	2000	// K: 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// DB
struct Road {
	int sCity, eCity, mToll;
	bool isRemoved;
};
Road roads[MAX_N];
int numRoads;
unordered_map<int, int> roadMap;	// ( 1 ≤ mId[i] ≤ 1,000,000,000 )

int N;		// 도시의 개수 ( 5 ≤ N ≤ 300 )
int K;		// 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// 그래프
struct Edge {
	int to, mToll;
};
vector<Edge> graph[MAX_N];		// 인접 리스트

// mId[i]: 도로 i의 ID ( 1 ≤ mId[i] ≤ 1,000,000,000 )
// mToll[i]: 도로 i의 통행료 ( 100 ≤ mToll[i] ≤ 1,000 )

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mToll) {
	int rIdx = roadMap[mId] = numRoads++;
	roads[rIdx] = { sCity, eCity, mToll, false };
	graph[sCity].push_back({ eCity, mToll });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[])
{
	::N = N, ::K = K;
	numRoads = 0;
	roadMap.clear();
	for (int i = 0; i < N; i++) graph[i].clear();

	for (int i = 0; i < K; i++) {
		add(mId[i], sCity[i], eCity[i], mToll[i]);
	}
}

void remove(int mId) {
	int rIdx = roadMap[mId];
	roads[rIdx].isRemoved = true;
}

int cost(int M, int sCity, int eCity) {
	return 0;
}
```

## claud3.7 - extended
```cpp
#include <vector>
#include <unordered_map>
#include <queue>
#include <climits>
using namespace std;

#define MAX_N	300		// N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K	2000	// K: 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// DB
struct Road {
	int sCity, eCity, mToll;
	bool isRemoved;
};
Road roads[MAX_N];
int numRoads;
unordered_map<int, int> roadMap;	// ( 1 ≤ mId[i] ≤ 1,000,000,000 )

int N;		// 도시의 개수 ( 5 ≤ N ≤ 300 )
int K;		// 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// 그래프
struct Edge {
	int to, mToll;
};
vector<Edge> graph[MAX_N];		// 인접 리스트

// mId[i]: 도로 i의 ID ( 1 ≤ mId[i] ≤ 1,000,000,000 )
// mToll[i]: 도로 i의 통행료 ( 100 ≤ mToll[i] ≤ 1,000 )

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mToll) {
	int rIdx = roadMap[mId] = numRoads++;
	roads[rIdx] = { sCity, eCity, mToll, false };
	graph[sCity].push_back({ eCity, mToll });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[])
{
	::N = N, ::K = K;
	numRoads = 0;
	roadMap.clear();
	for (int i = 0; i < N; i++) graph[i].clear();

	for (int i = 0; i < K; i++) {
		add(mId[i], sCity[i], eCity[i], mToll[i]);
	}
}

void remove(int mId) {
	int rIdx = roadMap[mId];
	roads[rIdx].isRemoved = true;
}

int cost(int M, int sCity, int eCity) {
    // 임시 그래프 생성 (삭제되지 않은 도로만 포함)
    vector<Edge> tempGraph[MAX_N];
    for (auto& pair : roadMap) {
        int idx = pair.second;
        if (!roads[idx].isRemoved) {
            tempGraph[roads[idx].sCity].push_back({roads[idx].eCity, roads[idx].mToll});
        }
    }
    
    // 최소 비용 배열: minCost[city][usedCoupons]
    int minCost[MAX_N][11];  // M은 최대 10
    
    // 초기화
    for (int i = 0; i < N; i++) {
        for (int j = 0; j <= M; j++) {
            minCost[i][j] = INT_MAX;
        }
    }
    
    // 다익스트라 알고리즘용 우선순위 큐
    // {비용, {도시, 사용한 할인권 수}}
    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
    
    // 시작 상태 초기화
    pq.push({0, {sCity, 0}});
    minCost[sCity][0] = 0;
    
    while (!pq.empty()) {
        int currCost = pq.top().first;
        int currCity = pq.top().second.first;
        int usedCoupons = pq.top().second.second;
        pq.pop();
        
        // 현재 상태의 비용이 이미 알려진 최소 비용보다 크면 무시
        if (currCost > minCost[currCity][usedCoupons]) continue;
        
        // 현재 도시에서 출발하는 모든 도로 탐색
        for (const Edge& edge : tempGraph[currCity]) {
            int nextCity = edge.to;
            int toll = edge.mToll;
            
            // 할인권을 사용하지 않는 경우
            int newCost = currCost + toll;
            if (newCost < minCost[nextCity][usedCoupons]) {
                minCost[nextCity][usedCoupons] = newCost;
                pq.push({newCost, {nextCity, usedCoupons}});
            }
            
            // 할인권을 사용하는 경우 (남은 할인권이 있을 때)
            if (usedCoupons < M) {
                // 통행료의 50% 할인
                int discountedCost = currCost + toll / 2;
                if (discountedCost < minCost[nextCity][usedCoupons + 1]) {
                    minCost[nextCity][usedCoupons + 1] = discountedCost;
                    pq.push({discountedCost, {nextCity, usedCoupons + 1}});
                }
            }
        }
    }
    
    // 도착 도시에 도달할 수 있는 모든 상태 중 최소 비용 계산
    int minResult = INT_MAX;
    for (int i = 0; i <= M; i++) {
        if (minCost[eCity][i] < minResult) {
            minResult = minCost[eCity][i];
        }
    }
    
    return minResult == INT_MAX ? -1 : minResult;
}
```

```cpp

```
