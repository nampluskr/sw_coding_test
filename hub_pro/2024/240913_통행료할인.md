## Template

```cpp
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

#define MAX_N	300		// N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K	2000	// K: 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// DB
struct Road {
	int sCity, eCity, mToll;
	bool isRemoved;
};
Road roads[MAX_N];
int numRoads;
unordered_map<int, int> roadMap;	// ( 1 ≤ mId[i] ≤ 1,000,000,000 )

int N;		// 도시의 개수 ( 5 ≤ N ≤ 300 )
int K;		// 도로의 개수 ( 6 ≤ K ≤ 2,000 )

// 그래프
struct Edge {
	int to, mToll;
};
vector<Edge> graph[MAX_N];		// 인접 리스트

// mId[i]: 도로 i의 ID ( 1 ≤ mId[i] ≤ 1,000,000,000 )
// mToll[i]: 도로 i의 통행료 ( 100 ≤ mToll[i] ≤ 1,000 )

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mToll) {
	int rIdx = roadMap[mId] = numRoads++;
	roads[rIdx] = { sCity, eCity, mToll, false };
	graph[sCity].push_back({ eCity, mToll });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[])
{
	::N = N, ::K = K;
	numRoads = 0;
	roadMap.clear();
	for (int i = 0; i < N; i++) graph[i].clear();

	for (int i = 0; i < K; i++) {
		add(mId[i], sCity[i], eCity[i], mToll[i]);
	}
}

void remove(int mId) {
	int rIdx = roadMap[mId];
	roads[rIdx].isRemoved = true;
}

int cost(int M, int sCity, int eCity) {
	return 0;
}
```

## Solved
```cpp
#include <vector>
#include <unordered_map>
#include <queue>
using namespace std;

#define MAX_N	300     		// 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K	(2000 + 1400)	// 도로의 최대 개수 (add 함수 최대 1400회)
#define MAX_M   11      		// 최대 할인권 개수 + 1
#define INF     1e6

// DB
struct Road {
	int sCity, eCity, mToll;
	bool isRemoved;     // 삭제 플래그 다시 추가
};
Road roads[MAX_K];
int numRoads;
unordered_map<int, int> roadMap;	// ( 1 ≤ mId[i] ≤ 1,000,000,000 )

int N;		// 도시의 개수 ( 5 ≤ N ≤ 300 )

// Graph
struct Edge {
    int to;             // 도착 도시
    int cost;           // 비용(통행료)
	int roadIdx;        // 도로 인덱스 (삭제 여부 확인용)
    int usedCoupons;    // 사용한 할인권 수 (다익스트라 알고리즘용 필드)

    bool operator<(const Edge& other) const { return cost > other.cost; }
};
vector<Edge> graph[MAX_N];		// 인접 리스트

priority_queue<Edge> pq;
int minCost[MAX_N][MAX_M];

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mToll) {
	int roadIdx = roadMap[mId] = numRoads++;
	roads[roadIdx] = { sCity, eCity, mToll, false };  // isRemoved 초기값 false
	graph[sCity].push_back({ eCity, mToll, roadIdx, 0 });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[])
{
	::N = N;
	numRoads = 0;
	roadMap.clear();
	for (int i = 0; i < N; i++) graph[i].clear();
	for (int i = 0; i < K; i++) add(mId[i], sCity[i], eCity[i], mToll[i]);
}

void remove(int mId) {
	int roadIdx = roadMap[mId];
	roads[roadIdx].isRemoved = true;
}

int cost(int M, int sCity, int eCity) {
    if (sCity == eCity) return 0;

	pq = {};
	for (int i = 0; i < N; i++)
        for (int j = 0; j <= M; j++)
            minCost[i][j] = INF;

    pq.push({ sCity, 0, 0, 0 });
    minCost[sCity][0] = 0;

    while (!pq.empty()) {
        auto curr = pq.top(); pq.pop();

		if (curr.to == eCity && curr.usedCoupons == M) break;
        if (curr.cost > minCost[curr.to][curr.usedCoupons]) continue;

        for (const auto& next : graph[curr.to]) {
            if (roads[next.roadIdx].isRemoved) continue;

            // 할인권을 사용하지 않는 경우
            int newCost = curr.cost + next.cost;
            if (newCost < minCost[next.to][curr.usedCoupons]) {
                minCost[next.to][curr.usedCoupons] = newCost;
                pq.push({ next.to, newCost, next.roadIdx, curr.usedCoupons });
            }

            // 할인권을 사용하는 경우 (남은 할인권이 있을 때)
            if (curr.usedCoupons < M) {
                newCost = curr.cost + (next.cost / 2);
                if (newCost < minCost[next.to][curr.usedCoupons + 1]) {
                    minCost[next.to][curr.usedCoupons + 1] = newCost;
                    pq.push({ next.to, newCost, next.roadIdx, curr.usedCoupons + 1 });
                }
            }
        }
    }

    int result = INF;
    for (int i = 0; i <= M; i++)
        if (minCost[eCity][i] < result)
            result = minCost[eCity][i];

    return result == INF ? -1 : result;
}
```

## KDH
```cpp
#include<vector>
#include<unordered_map>
#include<queue>
#include<algorithm>
using namespace std;

#define MAX_CITY 303
#define MAX_ROAD 3403
#define MAX_DISCOUNT_TICKET 11
#define INF 987654321

struct DB {
	int s, e, c;
}db[MAX_ROAD];

struct Edge {
	int to, cost, used_coupon;
	bool operator<(const Edge& r)const {
		return cost > r.cost;
	}
	bool operator==(const Edge& r)const {
		return to == r.to && cost == r.cost;
	}
};

vector<Edge> adj[MAX_CITY];
unordered_map<int, int> idMap;
int idCnt, N, M;

int getID(int c) {
	return idMap.count(c) ? idMap[c] : idMap[c] = idCnt++;
}

void add(int mId, int sCity, int eCity, int mToll) {
	db[getID(mId)] = { sCity, eCity, mToll };
	adj[sCity].push_back({ eCity,mToll });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mToll[]) {
	::N = N, idMap.clear(), idCnt = 0;
	for (int i = 0; i < MAX_CITY; i++) adj[i].clear();
	for (int i = 0; i < K; i++)	add(mId[i], sCity[i], eCity[i], mToll[i]);
}

void remove(int mId) {
	int id = getID(mId);
	int s = db[id].s, e = db[id].e, c = db[id].c;
	adj[s].erase(find(adj[s].begin(), adj[s].end(), Edge{ e, c }));
}

int costFinal[MAX_CITY][MAX_DISCOUNT_TICKET]; // 사용한 할인권 개수에 따른 최소 비용
int cost(int m, int s, int e) {
	for (int i = 0; i < N; i++) for (int j = 0; j < MAX_DISCOUNT_TICKET; j++) costFinal[i][j] = INF;
	costFinal[s][0] = 0;
	priority_queue<Edge> pq;
	pq.push({ s, 0, 0 }); // to, cost, used_coupon

	while (!pq.empty()) {
		Edge cur = pq.top(); pq.pop();
		if (cur.to == e && cur.used_coupon == m) {
			int ret = INF;
			for (int i = 1; i <= m; i++) ret = min(ret, costFinal[e][i]); // 할인권을 사용한다는 가정이 있음
			return ret == INF ? -1 : ret;
		}

		if (cur.cost > costFinal[cur.to][cur.used_coupon]) continue;

		for (Edge nx : adj[cur.to]) {
			int nextCost = cur.cost + nx.cost;
			if (costFinal[nx.to][cur.used_coupon] > nextCost) { // 할인권을 사용하지 않는 경우
				costFinal[nx.to][cur.used_coupon] = nextCost;
				pq.push({ nx.to, nextCost, cur.used_coupon });
			}
			if (cur.used_coupon <= m) { // 할인권을 사용할 수 있는 경우
				int discountCost = cur.cost + nx.cost / 2;
				//int discountCost = cost + (int)ceil(nx.cost / 2.0);
				if (costFinal[nx.to][cur.used_coupon + 1] > discountCost) {
					costFinal[nx.to][cur.used_coupon + 1] = discountCost;
					pq.push({ nx.to, discountCost, cur.used_coupon + 1 });
				}
			}
		}
	}
	return -1; // 도착하지 못하는 경우
}
```
