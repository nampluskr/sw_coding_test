## Template

```cpp
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

#define MAX_N 300           // N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K (1000 + 700)  // K: 도로의 개수 ( 6 ≤ K ≤ 1,000 ), add() 호출 횟수 700 이하
#define MAX_COST 500        // mCost[i]: 도로 i의 비용 ( 1 ≤ mCost[i] ≤ 500 )

// DB
struct Road {
    int sCity, eCity, mCost;
    int isRemoved;
};
Road roads[MAX_N];
int numRoads;
unordered_map<int, int> roadMap;
int N;

// Graph
struct Edge {
    int to, mCost;
    bool operator<(const Edge& other) const { mCost > other.mCost; }
};
vector<Edge> graph[MAX_N];
bool visited[MAX_N];
int dist[MAX_N];

priority_queue<Edge> pq;
queue<Edge> q;

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mCost)
{
    int roadIdx = roadMap[mId] = numRoads++;
    roads[roadIdx] = { sCity, eCity, mCost, true };
    graph[sCity].push_back({ eCity, mCost });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[])
{
    ::N = N;
    numRoads = 0;
    roadMap.clear();
    for (int i = 0; i < N; i++) graph[i].clear();
    for (int i = 0; i < K; i++) add(mId[i], sCity[i], eCity[i], mCost[i]);
}

void remove(int mId)
{
    int roadIdx = roadMap[mId];
    roads[roadIdx].isRemoved = true;
}

int cost(int sCity, int eCity)
{

	return 0;
}
```

## Solved: Dijkstra

```cpp

```

## Solved: BFS + Two Pointers

```cpp

```
