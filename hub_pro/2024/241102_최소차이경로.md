## Template

```cpp
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

#define MAX_N 300           // N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K (1000 + 700)  // K: 도로의 개수 ( 6 ≤ K ≤ 1,000 ), add() 호출 횟수 700 이하
#define MAX_COST 500        // mCost[i]: 도로 i의 비용 ( 1 ≤ mCost[i] ≤ 500 )

// DB
struct Road {
    int sCity, eCity, mCost;
    int isRemoved;
};
Road roads[MAX_N];
int numRoads;
unordered_map<int, int> roadMap;
int N;

// Graph
struct Edge {
    int to, mCost;
    bool operator<(const Edge& other) const { mCost > other.mCost; }
};
vector<Edge> graph[MAX_N];
bool visited[MAX_N];
int dist[MAX_N];

priority_queue<Edge> pq;
queue<Edge> q;

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mCost)
{
    int roadIdx = roadMap[mId] = numRoads++;
    roads[roadIdx] = { sCity, eCity, mCost, true };
    graph[sCity].push_back({ eCity, mCost });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[])
{
    ::N = N;
    numRoads = 0;
    roadMap.clear();
    for (int i = 0; i < N; i++) graph[i].clear();
    for (int i = 0; i < K; i++) add(mId[i], sCity[i], eCity[i], mCost[i]);
}

void remove(int mId)
{
    int roadIdx = roadMap[mId];
    roads[roadIdx].isRemoved = true;
}

int cost(int sCity, int eCity)
{

	return 0;
}
```

## Solved: Dijkstra

```cpp
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

#define MAX_N 300           // N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K (1000 + 700)  // K: 도로의 개수 ( 6 ≤ K ≤ 1,000 ), add() 호출 횟수 700 이하
#define MAX_COST 500        // mCost[i]: 도로 i의 비용 ( 1 ≤ mCost[i] ≤ 500 )

// DB
struct Road {
    int sCity, eCity, mCost;
    int isRemoved;
};
Road roads[MAX_K];
int numRoads;
unordered_map<int, int> roadMap;
int N;

// Graph
struct Edge {
    int city, mCost;
    int max_cost, min_cost;
    
    // 목적지와 비용만 필요한 경우의 생성자
    Edge(int _city, int _cost) : city(_city), mCost(_cost), max_cost(0), min_cost(0) {}
    
    // 모든 필드를 초기화하는 생성자
    Edge(int _city, int _maxCost, int _minCost) : city(_city), mCost(0), max_cost(_maxCost), min_cost(_minCost) {}
    
    bool operator<(const Edge& other) const { 
        // 최대-최소 도로 비용의 차이 기준 최소 힙
        return (max_cost - min_cost) > (other.max_cost - other.min_cost);
    }
};
vector<Edge> graph[MAX_N];

void add(int mId, int sCity, int eCity, int mCost)
{
    int roadIdx = roadMap[mId] = numRoads++;
    roads[roadIdx] = { sCity, eCity, mCost, 0 };  // isRemoved = 0 (false)
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[])
{
    ::N = N;
    numRoads = 0;
    roadMap.clear();
    for (int i = 0; i < K; i++) {
        add(mId[i], sCity[i], eCity[i], mCost[i]);
    }
}

void remove(int mId)
{
    int roadIdx = roadMap[mId];
    roads[roadIdx].isRemoved = 1;  // Mark as removed
}

int cost(int sCity, int eCity)
{
    // 특별 케이스: 시작점과 끝점이 같은 경우
    if (sCity == eCity) {
        return 0;
    }
    
    // 활성화된 도로만 포함하도록 그래프 재구성
    for (int i = 0; i < N; i++) {
        graph[i].clear();
    }
    
    for (int i = 0; i < numRoads; i++) {
        if (!roads[i].isRemoved) {
            int s = roads[i].sCity;
            int e = roads[i].eCity;
            int c = roads[i].mCost;
            graph[s].push_back(Edge(e, c));
        }
    }
    
    // 각 도시에 대한 최소 차이 추적
    int best_diff[MAX_N];
    for (int i = 0; i < N; i++) {
        best_diff[i] = MAX_COST + 1;  // 가능한 차이보다 큰 값으로 초기화
    }
    
    // 우선순위 큐 초기화
    priority_queue<Edge> pq;
    
    // 출발 도시에서 직접 연결된 간선 처리
    for (const Edge& edge : graph[sCity]) {
        int next_city = edge.city;
        int edge_cost = edge.mCost;
        
        pq.push(Edge(next_city, edge_cost, edge_cost));
        best_diff[next_city] = 0;  // 첫 번째 간선의 차이는 0
        
        // 목적지에 직접 도달할 수 있으면 바로 반환
        if (next_city == eCity) {
            return 0;
        }
    }
    
    while (!pq.empty()) {
        Edge curr = pq.top();
        pq.pop();
        
        int city = curr.city;
        int max_cost = curr.max_cost;
        int min_cost = curr.min_cost;
        
        int curr_diff = max_cost - min_cost;
        
        // 이미 더 좋은 경로를 찾았으면 스킵
        if (curr_diff > best_diff[city]) {
            continue;
        }
        
        // 목적지에 도달했으면 결과 반환
        if (city == eCity) {
            return curr_diff;
        }
        
        // 인접 도시 탐색
        for (const Edge& edge : graph[city]) {
            int next_city = edge.city;
            int edge_cost = edge.mCost;
            
            int new_max_cost = max(max_cost, edge_cost);
            int new_min_cost = min(min_cost, edge_cost);
            
            int new_diff = new_max_cost - new_min_cost;
            
            // 더 좋은 경로로 이어질 수 있는 경우만 탐색
            if (new_diff < best_diff[next_city]) {
                best_diff[next_city] = new_diff;
                pq.push(Edge(next_city, new_max_cost, new_min_cost));
            }
        }
    }
    
    // 목적지에 도달할 수 없는 경우
    return best_diff[eCity] == MAX_COST + 1 ? -1 : best_diff[eCity];
}
```

## Solved: BFS + Binary Search

```cpp
#include <vector>
#include <queue>
#include <unordered_map>
#include <set>
#include <algorithm>
using namespace std;

#define MAX_N 300           // N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K (1000 + 700)  // K: 도로의 개수 ( 6 ≤ K ≤ 1,000 ), add() 호출 횟수 700 이하
#define MAX_COST 500        // mCost[i]: 도로 i의 비용 ( 1 ≤ mCost[i] ≤ 500 )

// DB
struct Road {
    int sCity, eCity, mCost;
    int isRemoved;
};
Road roads[MAX_K];
int numRoads;
unordered_map<int, int> roadMap;
int N;

// Graph
struct Edge {
    int to, mCost;
};
vector<Edge> graph[MAX_N];

void add(int mId, int sCity, int eCity, int mCost)
{
    int roadIdx = roadMap[mId] = numRoads++;
    roads[roadIdx] = { sCity, eCity, mCost, 0 };  // isRemoved = 0 (false)
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[])
{
    ::N = N;
    numRoads = 0;
    roadMap.clear();
    for (int i = 0; i < N; i++) graph[i].clear();
    for (int i = 0; i < K; i++) {
        add(mId[i], sCity[i], eCity[i], mCost[i]);
    }
}

void remove(int mId)
{
    int roadIdx = roadMap[mId];
    roads[roadIdx].isRemoved = 1;  // Mark as removed
}

// 그래프 재구성 함수
void rebuildGraph() {
    for (int i = 0; i < N; i++) {
        graph[i].clear();
    }
    
    for (int i = 0; i < numRoads; i++) {
        if (!roads[i].isRemoved) {
            int s = roads[i].sCity;
            int e = roads[i].eCity;
            int c = roads[i].mCost;
            graph[s].push_back({e, c});
        }
    }
}

// BFS로 특정 비용 범위 내에서 도달 가능한지 확인하는 함수
bool canReach(int sCity, int eCity, int minCost, int maxCost) {
    bool visited[MAX_N] = {0};
    queue<int> q;
    
    q.push(sCity);
    visited[sCity] = true;
    
    while (!q.empty()) {
        int city = q.front();
        q.pop();
        
        if (city == eCity) {
            return true;
        }
        
        // 인접 도시 탐색
        for (const Edge& edge : graph[city]) {
            int nextCity = edge.to;
            int roadCost = edge.mCost;
            
            // 비용 범위 내에 있고 아직 방문하지 않은 도시라면
            if (minCost <= roadCost && roadCost <= maxCost && !visited[nextCity]) {
                visited[nextCity] = true;
                q.push(nextCity);
            }
        }
    }
    
    return false;
}

// 특정 차이 값으로 도달 가능한지 확인하는 함수
bool canReachWithDiff(int sCity, int eCity, int diff, const vector<int>& costs) {
    // 모든 가능한 최소 비용에 대해 검사
    for (int minCost : costs) {
        int maxCost = minCost + diff;
        
        // 최대 비용이 제한 범위를 넘어가면 건너뜀
        if (maxCost > MAX_COST) continue;
        
        if (canReach(sCity, eCity, minCost, maxCost)) {
            return true;
        }
    }
    
    return false;
}

int cost(int sCity, int eCity)
{
    // 특별 케이스: 시작점과 끝점이 같은 경우
    if (sCity == eCity) {
        return 0;
    }
    
    // 그래프 재구성
    rebuildGraph();
    
    // 모든 가능한 비용을 수집
    set<int> costSet;
    for (int i = 0; i < numRoads; i++) {
        if (!roads[i].isRemoved) {
            costSet.insert(roads[i].mCost);
        }
    }
    
    if (costSet.empty()) {
        return -1;  // 도로가 없는 경우
    }
    
    vector<int> costs(costSet.begin(), costSet.end());
    
    // 도달 가능 여부 먼저 확인 (모든 비용 허용)
    if (!canReach(sCity, eCity, 1, MAX_COST)) {
        return -1;
    }
    
    // 이분 탐색으로 최소 차이 값 찾기
    int left = 0;
    int right = MAX_COST;  // 최대 가능한 차이
    
    int result = -1;
    while (left <= right) {
        int mid = (left + right) / 2;
        
        if (canReachWithDiff(sCity, eCity, mid, costs)) {
            result = mid;
            // 더 작은 차이 값을 찾아봄
            right = mid - 1;
        } else {
            // 더 큰 차이 값을 찾아봄
            left = mid + 1;
        }
    }
    
    return result;
}
```

## Solved: BFS + Two Pointers

```cpp
#include <vector>
#include <queue>
#include <unordered_map>
#include <algorithm>
using namespace std;

#define MAX_N 300           // N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K (1000 + 700)  // K: 도로의 개수 ( 6 ≤ K ≤ 1,000 ), add() 호출 횟수 700 이하
#define MAX_COST 500        // mCost[i]: 도로 i의 비용 ( 1 ≤ mCost[i] ≤ 500 )

// DB
struct Road {
    int sCity, eCity, mCost;
    int isRemoved;
};
Road roads[MAX_K];
int numRoads;
unordered_map<int, int> roadMap;
int N;

// Graph
struct Edge {
    int to, mCost;
};
vector<Edge> graph[MAX_N];

void add(int mId, int sCity, int eCity, int mCost)
{
    int roadIdx = roadMap[mId] = numRoads++;
    roads[roadIdx] = { sCity, eCity, mCost, 0 };  // isRemoved = 0 (false)
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[])
{
    ::N = N;
    numRoads = 0;
    roadMap.clear();
    for (int i = 0; i < N; i++) graph[i].clear();
    for (int i = 0; i < K; i++) {
        add(mId[i], sCity[i], eCity[i], mCost[i]);
    }
}

void remove(int mId)
{
    int roadIdx = roadMap[mId];
    roads[roadIdx].isRemoved = 1;  // Mark as removed
}

// 그래프 재구성 함수
void rebuildGraph() {
    for (int i = 0; i < N; i++) {
        graph[i].clear();
    }
    
    for (int i = 0; i < numRoads; i++) {
        if (!roads[i].isRemoved) {
            int s = roads[i].sCity;
            int e = roads[i].eCity;
            int c = roads[i].mCost;
            graph[s].push_back({e, c});
        }
    }
}

// BFS로 특정 비용 범위 내에서 도달 가능한지 확인하는 함수
bool canReach(int sCity, int eCity, int minCost, int maxCost) {
    bool visited[MAX_N] = {0};
    queue<int> q;
    
    q.push(sCity);
    visited[sCity] = true;
    
    while (!q.empty()) {
        int city = q.front();
        q.pop();
        
        if (city == eCity) {
            return true;
        }
        
        // 인접 도시 탐색
        for (const Edge& edge : graph[city]) {
            int nextCity = edge.to;
            int roadCost = edge.mCost;
            
            // 비용 범위 내에 있고 아직 방문하지 않은 도시라면
            if (minCost <= roadCost && roadCost <= maxCost && !visited[nextCity]) {
                visited[nextCity] = true;
                q.push(nextCity);
            }
        }
    }
    
    return false;
}

int cost(int sCity, int eCity)
{
    // 특별 케이스: 시작점과 끝점이 같은 경우
    if (sCity == eCity) {
        return 0;
    }
    
    // 그래프 재구성
    rebuildGraph();
    
    // 모든 도로 비용 수집
    vector<int> allCosts;
    for (int i = 0; i < numRoads; i++) {
        if (!roads[i].isRemoved) {
            allCosts.push_back(roads[i].mCost);
        }
    }
    
    // 중복 제거 및 정렬
    sort(allCosts.begin(), allCosts.end());
    allCosts.erase(unique(allCosts.begin(), allCosts.end()), allCosts.end());
    
    if (allCosts.empty()) {
        return -1;  // 도로가 없는 경우
    }
    
    // 도달 가능 여부 먼저 확인 (모든 비용 허용)
    if (!canReach(sCity, eCity, 1, MAX_COST)) {
        return -1;
    }
    
    int n = allCosts.size();
    int minDiff = MAX_COST + 1;
    
    // Two Pointers 기법
    int left = 0, right = 0;
    
    while (right < n) {
        int minCost = allCosts[left];
        int maxCost = allCosts[right];
        int diff = maxCost - minCost;
        
        if (canReach(sCity, eCity, minCost, maxCost)) {
            // 도달 가능하면 결과 갱신
            minDiff = min(minDiff, diff);
            
            // 차이를 더 줄일 수 있는지 확인하기 위해 left 증가
            left++;
        } else {
            // 도달 불가능하면 범위 확장을 위해 right 증가
            right++;
        }
        
        // left가 right를 넘어가면 같이 조정
        if (left > right) {
            right = left;
        }
    }
    
    return minDiff == MAX_COST + 1 ? -1 : minDiff;
}
```
