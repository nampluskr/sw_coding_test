## Template

```cpp
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

#define MAX_N 300           // N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K (1000 + 700)  // K: 도로의 개수 ( 6 ≤ K ≤ 1,000 ), add() 호출 횟수 700 이하
#define MAX_COST 500        // mCost[i]: 도로 i의 비용 ( 1 ≤ mCost[i] ≤ 500 )

// DB
struct Road {
    int sCity, eCity, mCost;
    int isRemoved;
};
Road roads[MAX_N];
int numRoads;
unordered_map<int, int> roadMap;
int N;

// Graph
struct Edge {
    int to, mCost;
    bool operator<(const Edge& other) const { mCost > other.mCost; }
};
vector<Edge> graph[MAX_N];
bool visited[MAX_N];
int dist[MAX_N];

priority_queue<Edge> pq;
queue<Edge> q;

//////////////////////////////////////////////////////////////////////
void add(int mId, int sCity, int eCity, int mCost)
{
    int roadIdx = roadMap[mId] = numRoads++;
    roads[roadIdx] = { sCity, eCity, mCost, true };
    graph[sCity].push_back({ eCity, mCost });
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[])
{
    ::N = N;
    numRoads = 0;
    roadMap.clear();
    for (int i = 0; i < N; i++) graph[i].clear();
    for (int i = 0; i < K; i++) add(mId[i], sCity[i], eCity[i], mCost[i]);
}

void remove(int mId)
{
    int roadIdx = roadMap[mId];
    roads[roadIdx].isRemoved = true;
}

int cost(int sCity, int eCity)
{

	return 0;
}
```

## Solved: Dijkstra

```cpp
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

#define MAX_N 300           // N: 도시의 개수 ( 5 ≤ N ≤ 300 )
#define MAX_K (1000 + 700)  // K: 도로의 개수 ( 6 ≤ K ≤ 1,000 ), add() 호출 횟수 700 이하
#define MAX_COST 500        // mCost[i]: 도로 i의 비용 ( 1 ≤ mCost[i] ≤ 500 )

// DB
struct Road {
    int sCity, eCity, mCost;
    int isRemoved;
};
Road roads[MAX_K];
int numRoads;
unordered_map<int, int> roadMap;
int N;

// Graph
struct Edge {
    int city, mCost;
    int max_cost, min_cost;
    
    // 목적지와 비용만 필요한 경우의 생성자
    Edge(int _city, int _cost) : city(_city), mCost(_cost), max_cost(0), min_cost(0) {}
    
    // 모든 필드를 초기화하는 생성자
    Edge(int _city, int _maxCost, int _minCost) : city(_city), mCost(0), max_cost(_maxCost), min_cost(_minCost) {}
    
    bool operator<(const Edge& other) const { 
        // 최대-최소 도로 비용의 차이 기준 최소 힙
        return (max_cost - min_cost) > (other.max_cost - other.min_cost);
    }
};
vector<Edge> graph[MAX_N];

void add(int mId, int sCity, int eCity, int mCost)
{
    int roadIdx = roadMap[mId] = numRoads++;
    roads[roadIdx] = { sCity, eCity, mCost, 0 };  // isRemoved = 0 (false)
}

void init(int N, int K, int mId[], int sCity[], int eCity[], int mCost[])
{
    ::N = N;
    numRoads = 0;
    roadMap.clear();
    for (int i = 0; i < K; i++) {
        add(mId[i], sCity[i], eCity[i], mCost[i]);
    }
}

void remove(int mId)
{
    int roadIdx = roadMap[mId];
    roads[roadIdx].isRemoved = 1;  // Mark as removed
}

int cost(int sCity, int eCity)
{
    // 특별 케이스: 시작점과 끝점이 같은 경우
    if (sCity == eCity) {
        return 0;
    }
    
    // 활성화된 도로만 포함하도록 그래프 재구성
    for (int i = 0; i < N; i++) {
        graph[i].clear();
    }
    
    for (int i = 0; i < numRoads; i++) {
        if (!roads[i].isRemoved) {
            int s = roads[i].sCity;
            int e = roads[i].eCity;
            int c = roads[i].mCost;
            graph[s].push_back(Edge(e, c));
        }
    }
    
    // 각 도시에 대한 최소 차이 추적
    int best_diff[MAX_N];
    for (int i = 0; i < N; i++) {
        best_diff[i] = MAX_COST + 1;  // 가능한 차이보다 큰 값으로 초기화
    }
    
    // 우선순위 큐 초기화
    priority_queue<Edge> pq;
    
    // 출발 도시에서 직접 연결된 간선 처리
    for (const Edge& edge : graph[sCity]) {
        int next_city = edge.city;
        int edge_cost = edge.mCost;
        
        pq.push(Edge(next_city, edge_cost, edge_cost));
        best_diff[next_city] = 0;  // 첫 번째 간선의 차이는 0
        
        // 목적지에 직접 도달할 수 있으면 바로 반환
        if (next_city == eCity) {
            return 0;
        }
    }
    
    while (!pq.empty()) {
        Edge curr = pq.top();
        pq.pop();
        
        int city = curr.city;
        int max_cost = curr.max_cost;
        int min_cost = curr.min_cost;
        
        int curr_diff = max_cost - min_cost;
        
        // 이미 더 좋은 경로를 찾았으면 스킵
        if (curr_diff > best_diff[city]) {
            continue;
        }
        
        // 목적지에 도달했으면 결과 반환
        if (city == eCity) {
            return curr_diff;
        }
        
        // 인접 도시 탐색
        for (const Edge& edge : graph[city]) {
            int next_city = edge.city;
            int edge_cost = edge.mCost;
            
            int new_max_cost = max(max_cost, edge_cost);
            int new_min_cost = min(min_cost, edge_cost);
            
            int new_diff = new_max_cost - new_min_cost;
            
            // 더 좋은 경로로 이어질 수 있는 경우만 탐색
            if (new_diff < best_diff[next_city]) {
                best_diff[next_city] = new_diff;
                pq.push(Edge(next_city, new_max_cost, new_min_cost));
            }
        }
    }
    
    // 목적지에 도달할 수 없는 경우
    return best_diff[eCity] == MAX_COST + 1 ? -1 : best_diff[eCity];
}
```

## Solved: BFS + Two Pointers

```cpp

```
